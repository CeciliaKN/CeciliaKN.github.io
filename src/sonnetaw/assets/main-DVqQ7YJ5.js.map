{"version":3,"file":"main-DVqQ7YJ5.js","sources":["../../src/textProcessor.ts","../../src/analyzer.ts","../../src/main.ts"],"sourcesContent":["/**\r\n * Text processing utilities for preprocessing sonnet input\r\n */\r\n\r\n/**\r\n * Split text into lines, preserving empty lines\r\n */\r\nexport function splitLines(text: string): string[] {\r\n  return text.split('\\n');\r\n}\r\n\r\n/**\r\n * Tokenize a line into words\r\n * Preserves the original words before removing punctuation\r\n */\r\nexport function tokenizeLine(line: string): string[] {\r\n  // Split on whitespace and filter empty strings\r\n  return line.trim().split(/\\s+/).filter(word => word.length > 0);\r\n}\r\n\r\n/**\r\n * Remove punctuation from a word but preserve apostrophes\r\n * for contractions like \"it's\" or \"don't\"\r\n */\r\nexport function removePunctuation(word: string): string {\r\n  // First normalize all apostrophe variants to ASCII apostrophe\r\n  const normalized = word.replace(/['']/g, \"'\");\r\n  // Keep letters and apostrophes, remove everything else\r\n  return normalized.replace(/[^a-zA-Z']/g, '');\r\n}\r\n\r\n/**\r\n * Preprocess text: split lines and tokenize\r\n */\r\nexport function preprocessText(text: string): { lines: string[], tokens: string[][] } {\r\n  const lines = splitLines(text);\r\n  const tokens = lines.map(line => tokenizeLine(line));\r\n  return { lines, tokens };\r\n}\r\n","import type {\r\n  LineAnalysis,\r\n  SonnetAnalysis,\r\n  SonnetForm,\r\n  StressPattern,\r\n  WordAnalysis\r\n} from './types';\r\nimport { DictionaryService } from './dictionary';\r\nimport { tokenizeLine, removePunctuation } from './textProcessor';\r\n\r\n/**\r\n * Sonnet analyzer service\r\n */\r\nexport class SonnetAnalyzer {\r\n  constructor(private dictionary: DictionaryService) {}\r\n\r\n  /**\r\n   * Analyze a single line of text\r\n   * @param lineText The line to analyze\r\n   * @param lineNumber Line number in the poem\r\n   * @param expectedPattern Optional expected stress pattern for intelligent pronunciation selection\r\n   */\r\n  analyzeLine(lineText: string, lineNumber: number, expectedPattern?: StressPattern): LineAnalysis {\r\n    const words = tokenizeLine(lineText);\r\n    const wordAnalyses: WordAnalysis[] = [];\r\n    const stressPattern: StressPattern = [];\r\n\r\n    // First pass: analyze words without context\r\n    const preliminaryAnalyses: Array<{ word: string; options: WordAnalysis[] }> = [];\r\n    \r\n    for (const word of words) {\r\n      const cleaned = removePunctuation(word);\r\n      if (!cleaned) continue;\r\n\r\n      const allPronunciations = this.dictionary.getAllPronunciations(cleaned);\r\n      \r\n      if (!allPronunciations || allPronunciations.length === 0) {\r\n        // Word not in dictionary, use fallback\r\n        const analysis = this.dictionary.analyzeWord(cleaned);\r\n        preliminaryAnalyses.push({ word: cleaned, options: [analysis] });\r\n      } else if (allPronunciations.length === 1) {\r\n        // Only one pronunciation, use it\r\n        const analysis = this.dictionary.analyzeWord(cleaned);\r\n        preliminaryAnalyses.push({ word: cleaned, options: [analysis] });\r\n      } else {\r\n        // Multiple pronunciations available\r\n        const options = allPronunciations.map(phonemes => {\r\n          const syllables = this.dictionary.extractSyllables(phonemes);\r\n          const rhymeKey = this.dictionary.extractRhymeKey(phonemes);\r\n          return {\r\n            word: cleaned.toLowerCase(),\r\n            originalWord: cleaned,\r\n            syllables,\r\n            rhymeKey,\r\n            found: true\r\n          };\r\n        });\r\n        preliminaryAnalyses.push({ word: cleaned, options });\r\n      }\r\n    }\r\n\r\n    // If no expected pattern or all words have single pronunciation, use simple approach\r\n    const hasMultipleOptions = preliminaryAnalyses.some(w => w.options.length > 1);\r\n    if (!expectedPattern || !hasMultipleOptions) {\r\n      for (const wordData of preliminaryAnalyses) {\r\n        const analysis = wordData.options[0];\r\n        wordAnalyses.push(analysis);\r\n        for (const syllable of analysis.syllables) {\r\n          stressPattern.push(syllable.stress);\r\n        }\r\n      }\r\n    } else {\r\n      // Intelligent selection: try to match expected pattern\r\n      const bestCombination = this.findBestPronunciationCombination(\r\n        preliminaryAnalyses,\r\n        expectedPattern\r\n      );\r\n      \r\n      for (const analysis of bestCombination) {\r\n        wordAnalyses.push(analysis);\r\n        for (const syllable of analysis.syllables) {\r\n          stressPattern.push(syllable.stress);\r\n        }\r\n      }\r\n    }\r\n\r\n    // Get rhyme key from last word\r\n    const lastWord = wordAnalyses.length > 0 ? wordAnalyses[wordAnalyses.length - 1] : null;\r\n    let rhymeKey = lastWord?.rhymeKey || '';\r\n    \r\n    // If last word has no rhyme key (all consonants), look backward for last vowel in line\r\n    if (rhymeKey === '' && wordAnalyses.length > 0) {\r\n      for (let i = wordAnalyses.length - 1; i >= 0; i--) {\r\n        if (wordAnalyses[i].rhymeKey) {\r\n          rhymeKey = wordAnalyses[i].rhymeKey;\r\n          break;\r\n        }\r\n      }\r\n    }\r\n\r\n    return {\r\n      lineNumber,\r\n      text: lineText,\r\n      words: wordAnalyses,\r\n      stressPattern,\r\n      rhymeKey\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Find the best combination of pronunciations to match expected pattern\r\n   * Uses a greedy approach for efficiency\r\n   */\r\n  private findBestPronunciationCombination(\r\n    wordOptions: Array<{ word: string; options: WordAnalysis[] }>,\r\n    expectedPattern: StressPattern\r\n  ): WordAnalysis[] {\r\n    const result: WordAnalysis[] = [];\r\n    let currentPosition = 0;\r\n\r\n    for (const wordData of wordOptions) {\r\n      if (wordData.options.length === 1) {\r\n        // No choice, use the only option\r\n        result.push(wordData.options[0]);\r\n        currentPosition += wordData.options[0].syllables.length;\r\n        continue;\r\n      }\r\n\r\n      // Score each pronunciation option\r\n      let bestOption = wordData.options[0];\r\n      let bestScore = -Infinity;\r\n\r\n      for (const option of wordData.options) {\r\n        let score = 0;\r\n        const syllableCount = option.syllables.length;\r\n        \r\n        // Check how well this pronunciation fits the expected pattern\r\n        for (let i = 0; i < syllableCount; i++) {\r\n          const globalPos = currentPosition + i;\r\n          if (globalPos >= expectedPattern.length) break;\r\n          \r\n          const expected = expectedPattern[globalPos];\r\n          const actual = option.syllables[i].stress;\r\n          \r\n          // Reward matching stress patterns\r\n          if (expected === 1 && actual === 1) {\r\n            score += 10; // Perfect match: expected stress and has stress\r\n          } else if (expected === 1 && actual === 2) {\r\n            score += 7; // Good match: expected stress and has secondary stress\r\n          } else if (expected === 0 && actual === 0) {\r\n            score += 5; // Good match: expected unstressed and is unstressed\r\n          } else if (expected === 1 && actual === 0) {\r\n            score -= 10; // Bad: expected stress but unstressed\r\n          } else if (expected === 0 && actual > 0) {\r\n            score -= 3; // Minor penalty: unstressed position but has stress\r\n          }\r\n        }\r\n        \r\n        // Prefer pronunciations that don't overshoot the expected length\r\n        const remainingSlots = expectedPattern.length - currentPosition;\r\n        if (syllableCount <= remainingSlots) {\r\n          score += 2;\r\n        } else {\r\n          score -= 5;\r\n        }\r\n\r\n        if (score > bestScore) {\r\n          bestScore = score;\r\n          bestOption = option;\r\n        }\r\n      }\r\n\r\n      result.push(bestOption);\r\n      currentPosition += bestOption.syllables.length;\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Check if stress pattern matches expected meter\r\n   * Returns true if valid, false if there are issues\r\n   * Rules vary by meter type (iambic, trochaic, etc.)\r\n   */\r\n  checkMeter(\r\n    actual: StressPattern, \r\n    expected: StressPattern, \r\n    meterType: string = 'iambic',\r\n    strict: boolean = false\r\n  ): boolean {\r\n    // If syllable count is way off (more than 2 syllables difference), skip checking\r\n    if (Math.abs(actual.length - expected.length) > 2) {\r\n      return false; // Will be handled as unchecked line\r\n    }\r\n\r\n    // Check if length matches\r\n    if (actual.length !== expected.length) {\r\n      // In lenient mode, allow ±1 syllable difference by trying to fit\r\n      if (!strict && Math.abs(actual.length - expected.length) === 1) {\r\n        return this.checkMeterWithFitting(actual, expected, meterType);\r\n      }\r\n      return false;\r\n    }\r\n\r\n    // Apply checking rules based on meter type\r\n    if (meterType === 'iambic') {\r\n      return strict ? this.checkStrictMeter(actual, expected) : this.checkIambicMeter(actual, expected);\r\n    } else {\r\n      // For other meter types, use strict checking\r\n      return this.checkStrictMeter(actual, expected);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Try to fit actual stress pattern to expected by skipping or padding\r\n   * Used in lenient mode when there's ±1 syllable difference\r\n   */\r\n  private checkMeterWithFitting(\r\n    actual: StressPattern,\r\n    expected: StressPattern,\r\n    meterType: string\r\n  ): boolean {\r\n    if (actual.length === expected.length + 1) {\r\n      // One extra syllable - try removing each position and check\r\n      for (let skip = 0; skip < actual.length; skip++) {\r\n        const fitted = actual.filter((_, i) => i !== skip);\r\n        if (meterType === 'iambic') {\r\n          if (this.checkIambicMeter(fitted, expected)) return true;\r\n        } else {\r\n          if (this.checkStrictMeter(fitted, expected)) return true;\r\n        }\r\n      }\r\n    } else if (actual.length === expected.length - 1) {\r\n      // One fewer syllable - try inserting unstressed at each position\r\n      for (let insert = 0; insert <= actual.length; insert++) {\r\n        const fitted = [...actual.slice(0, insert), 0, ...actual.slice(insert)] as StressPattern;\r\n        if (meterType === 'iambic') {\r\n          if (this.checkIambicMeter(fitted, expected)) return true;\r\n        } else {\r\n          if (this.checkStrictMeter(fitted, expected)) return true;\r\n        }\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Iambic meter checking (抑扬格)\r\n   * Lenient: allows \"light→heavy\" (0→1), but flags:\r\n   * - \"heavy→light\" (1→0): wrong stress position\r\n   * - \"light→light\" (0→0) when expecting heavy (1): missing stress\r\n   */\r\n  private checkIambicMeter(actual: StressPattern, expected: StressPattern): boolean {\r\n    for (let i = 0; i < expected.length; i++) {\r\n      if (expected[i] === 1) {\r\n        // Expected stressed position\r\n        if (actual[i] === 0) {\r\n          // Got unstressed (0) when expecting stressed (1) - ERROR: \"轻轻\"\r\n          return false;\r\n        }\r\n        // Allow actual[i] === 1 (correct) or actual[i] === 2 (secondary stress, acceptable)\r\n      } else {\r\n        // Expected unstressed position (expected[i] === 0)\r\n        if (actual[i] === 1) {\r\n          // Got stressed (1) in unstressed position - ALLOWED for flexibility\r\n          // (单音节词可以轻读)\r\n          continue;\r\n        }\r\n        // actual[i] === 0 or 2 are both fine for unstressed positions\r\n      }\r\n    }\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Strict meter checking for non-iambic meters\r\n   * Requires exact match of stress pattern, but allows stressed syllables in unstressed positions\r\n   */\r\n  private checkStrictMeter(actual: StressPattern, expected: StressPattern): boolean {\r\n    for (let i = 0; i < expected.length; i++) {\r\n      if (expected[i] === 1 && actual[i] === 0) {\r\n        return false; // Expected primary stress, got unstressed - error\r\n      }\r\n      // Allow stressed syllables (1 or 2) in unstressed positions (expected === 0)\r\n      // This makes strict mode less strict as requested\r\n    }\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Validate rhyme scheme\r\n   */\r\n  validateRhymeScheme(lines: LineAnalysis[], expectedScheme: string[]): {\r\n    valid: boolean;\r\n    issues: string[];\r\n    rhymeGroups: { [letter: string]: number[] }; // Map rhyme letters to line indices\r\n  } {\r\n    const rhymeGroups: { [letter: string]: number[] } = {};\r\n    const rhymeKeys: { [letter: string]: string[] } = {};\r\n    const issues: string[] = [];\r\n\r\n    // Group lines by their rhyme scheme letter\r\n    for (let i = 0; i < Math.min(lines.length, expectedScheme.length); i++) {\r\n      const letter = expectedScheme[i];\r\n      const rhymeKey = lines[i].rhymeKey;\r\n\r\n      if (!rhymeGroups[letter]) {\r\n        rhymeGroups[letter] = [];\r\n        rhymeKeys[letter] = [];\r\n      }\r\n      rhymeGroups[letter].push(i);\r\n      rhymeKeys[letter].push(rhymeKey);\r\n    }\r\n\r\n    // Check that all lines in each rhyme group have the same rhyme key\r\n    for (const [letter, lineIndices] of Object.entries(rhymeGroups)) {\r\n      // Skip single-line rhyme groups (no checking needed)\r\n      if (lineIndices.length <= 1) {\r\n        continue;\r\n      }\r\n\r\n      const rhymes = rhymeKeys[letter];\r\n      const validRhymes = rhymes.filter(r => r !== '');\r\n      const uniqueRhymes = new Set(validRhymes);\r\n      \r\n      // Check if there are multiple different rhymes\r\n      if (uniqueRhymes.size > 1) {\r\n        issues.push(`Rhyme group ${letter} has inconsistent rhymes: ${Array.from(uniqueRhymes).join(', ')}`);\r\n      }\r\n      \r\n      // Check for missing rhyme keys (words not in dictionary)\r\n      if (validRhymes.length < rhymes.length) {\r\n        issues.push(`Rhyme group ${letter} contains words not found in dictionary`);\r\n      }\r\n    }\r\n\r\n    return {\r\n      valid: issues.length === 0,\r\n      issues,\r\n      rhymeGroups\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Analyze an entire sonnet\r\n   */\r\n  analyzeSonnet(\r\n    text: string, \r\n    form: SonnetForm, \r\n    options: { strict?: boolean; intelligent?: boolean } = {}\r\n  ): SonnetAnalysis {\r\n    const strict = options.strict ?? false;\r\n    const intelligent = options.intelligent ?? true;\r\n    \r\n    const lines = text.split('\\n').filter(line => line.trim().length > 0);\r\n    \r\n    // First pass: analyze lines with expected stress pattern for intelligent pronunciation selection\r\n    const lineAnalyses: LineAnalysis[] = lines.map((line, index) => {\r\n      const analysis = this.analyzeLine(line, index + 1, form.meter.stressPattern);\r\n      \r\n      // Check meter\r\n      analysis.expectedStressPattern = form.meter.stressPattern;\r\n      analysis.meterValid = this.checkMeter(\r\n        analysis.stressPattern,\r\n        form.meter.stressPattern,\r\n        form.meter.type || 'iambic', // Default to iambic if not specified\r\n        strict\r\n      );\r\n\r\n      return analysis;\r\n    });\r\n\r\n    // Validate rhyme scheme\r\n    const rhymeValidation = this.validateRhymeScheme(lineAnalyses, form.rhymeScheme);\r\n\r\n    // Check meter validity\r\n    const meterIssues: string[] = [];\r\n    for (const line of lineAnalyses) {\r\n      // Skip lines that are too far off or have no valid words\r\n      if (line.words.length === 0 || Math.abs(line.stressPattern.length - form.meter.stressPattern.length) > 2) {\r\n        continue;\r\n      }\r\n      \r\n      if (!line.meterValid) {\r\n        meterIssues.push(\r\n          `Line ${line.lineNumber}: Expected ${form.meter.stressPattern.length} syllables ` +\r\n          `with pattern ${form.meter.stressPattern.join('')}, ` +\r\n          `got ${line.stressPattern.length} syllables with pattern ${line.stressPattern.join('')}`\r\n        );\r\n      }\r\n    }\r\n\r\n    return {\r\n      lines: lineAnalyses,\r\n      form,\r\n      rhymeSchemeValid: rhymeValidation.valid,\r\n      meterValid: meterIssues.length === 0,\r\n      rhymeIssues: rhymeValidation.issues,\r\n      meterIssues,\r\n      rhymeGroups: rhymeValidation.rhymeGroups\r\n    };\r\n  }\r\n}\r\n","import { DictionaryService } from './dictionary';\r\nimport { SonnetAnalyzer } from './analyzer';\r\nimport type { SonnetAnalysis, LineAnalysis, SonnetForm } from './types';\r\nimport { getDictionaryUrl, SUPPORTED_LANGUAGES } from './config';\r\n\r\n// Initialize services\r\nconst dictionary = new DictionaryService();\r\nconst analyzer = new SonnetAnalyzer(dictionary);\r\n\r\n// Dictionary loading state\r\nlet dictionaryLoaded = false;\r\nlet currentLanguage = 'en'; // 当前使用的语言\r\nlet currentForm: SonnetForm | null = null; // 当前选择的诗歌形式\r\n\r\n// Check if running in Tauri (desktop app)\r\nconst isTauri = '__TAURI__' in window;\r\n\r\n// Load dictionary from remote source (web) or local file (Tauri)\r\nasync function loadDictionary(languageCode: string = 'en') {\r\n  try {\r\n    let dictionaryData;\r\n    dictionaryLoaded = false; // 重置状态\r\n    \r\n    if (isTauri) {\r\n      // Desktop app: load from bundled local file\r\n      console.log(`Loading dictionary from local file (Tauri mode) - Language: ${languageCode}...`);\r\n      const language = SUPPORTED_LANGUAGES.find(lang => lang.code === languageCode);\r\n      if (!language) {\r\n        throw new Error(`Unsupported language: ${languageCode}`);\r\n      }\r\n      const response = await fetch(`/data/${language.dictionaryFile}`);\r\n      if (!response.ok) {\r\n        throw new Error(`Failed to load local dictionary: ${response.statusText}`);\r\n      }\r\n      dictionaryData = await response.json();\r\n      console.log(`Dictionary loaded successfully from local file - ${language.name}`);\r\n    } else {\r\n      // Web app: load from GitHub (saves hosting space)\r\n      console.log(`Loading dictionary from GitHub (web mode) - Language: ${languageCode}...`);\r\n      const dictionaryUrl = getDictionaryUrl(languageCode);\r\n      const response = await fetch(dictionaryUrl);\r\n      if (!response.ok) {\r\n        throw new Error(`Failed to load dictionary: ${response.statusText}`);\r\n      }\r\n      dictionaryData = await response.json();\r\n      console.log('Dictionary loaded successfully from GitHub repository');\r\n    }\r\n    \r\n    await dictionary.loadDictionary(dictionaryData, languageCode);\r\n    currentLanguage = languageCode;\r\n    dictionaryLoaded = true;\r\n  } catch (error) {\r\n    console.error('Error loading dictionary:', error);\r\n    const errorMsg = isTauri \r\n      ? 'Failed to load pronunciation dictionary from local files.'\r\n      : 'Failed to load pronunciation dictionary. Please check your internet connection.';\r\n    alert(errorMsg);\r\n  }\r\n}\r\n\r\n// Load dictionary on startup\r\nloadDictionary();\r\n\r\n// DOM elements\r\nconst languageSelect = document.getElementById('languageSelect') as HTMLSelectElement;\r\nconst poemInput = document.getElementById('poemInput') as HTMLTextAreaElement;\r\nconst sonnetForm = document.getElementById('sonnetForm') as HTMLSelectElement;\r\nconst meterMode = document.getElementById('meterMode') as HTMLSelectElement;\r\nconst intelligentMode = document.getElementById('intelligentMode') as HTMLInputElement;\r\nconst analyzeBtn = document.getElementById('analyzeBtn') as HTMLButtonElement;\r\nconst clearBtn = document.getElementById('clearBtn') as HTMLButtonElement;\r\nconst output = document.getElementById('output') as HTMLDivElement;\r\n\r\n// Populate language selector\r\nfunction initLanguageSelector() {\r\n  languageSelect.innerHTML = '';\r\n  for (const lang of SUPPORTED_LANGUAGES) {\r\n    const option = document.createElement('option');\r\n    option.value = lang.code;\r\n    option.textContent = lang.name;\r\n    if (lang.code === currentLanguage) {\r\n      option.selected = true;\r\n    }\r\n    languageSelect.appendChild(option);\r\n  }\r\n}\r\n\r\n// Populate poetic form selector based on current language\r\nfunction updateFormSelector() {\r\n  sonnetForm.innerHTML = '';\r\n  const language = SUPPORTED_LANGUAGES.find(lang => lang.code === currentLanguage);\r\n  \r\n  if (!language || language.poeticForms.length === 0) {\r\n    const option = document.createElement('option');\r\n    option.textContent = 'No forms available';\r\n    option.disabled = true;\r\n    sonnetForm.appendChild(option);\r\n    currentForm = null;\r\n    return;\r\n  }\r\n\r\n  for (const form of language.poeticForms) {\r\n    const option = document.createElement('option');\r\n    option.value = form.id;\r\n    option.textContent = form.name;\r\n    option.title = form.description;\r\n    sonnetForm.appendChild(option);\r\n  }\r\n  \r\n  // Set the first form as current\r\n  if (language.poeticForms.length > 0) {\r\n    currentForm = language.poeticForms[0];\r\n  }\r\n}\r\n\r\n// Handle language change\r\nlanguageSelect.addEventListener('change', async () => {\r\n  const newLanguage = languageSelect.value;\r\n  if (newLanguage !== currentLanguage) {\r\n    console.log(`Switching language to: ${newLanguage}`);\r\n    output.innerHTML = '<p style=\"color: #999; font-style: italic;\">Loading dictionary...</p>';\r\n    await loadDictionary(newLanguage);\r\n    if (dictionaryLoaded) {\r\n      updateFormSelector(); // Update available forms\r\n      output.innerHTML = '<p style=\"color: #999; font-style: italic;\">Dictionary loaded. Ready to analyze.</p>';\r\n    }\r\n  }\r\n});\r\n\r\n// Handle form change\r\nsonnetForm.addEventListener('change', () => {\r\n  const formId = sonnetForm.value;\r\n  const language = SUPPORTED_LANGUAGES.find(lang => lang.code === currentLanguage);\r\n  if (language) {\r\n    currentForm = language.poeticForms.find(form => form.id === formId) || null;\r\n  }\r\n});\r\n\r\n// Initialize selectors\r\ninitLanguageSelector();\r\nupdateFormSelector();\r\n\r\n/**\r\n * Get color for rhyme scheme letter\r\n */\r\nfunction getRhymeColor(letter: string): string {\r\n  const colors: { [key: string]: string } = {\r\n    'A': '#8B4513', // Saddle Brown\r\n    'B': '#4682B4', // Steel Blue  \r\n    'C': '#6B8E23', // Olive Drab\r\n    'D': '#B8860B', // Dark Goldenrod\r\n    'E': '#8B008B', // Dark Magenta\r\n    'F': '#CD5C5C', // Indian Red\r\n    'G': '#2F4F4F', // Dark Slate Gray\r\n    'H': '#556B2F', // Dark Olive Green\r\n  };\r\n  return colors[letter] || '#666';\r\n}\r\n\r\n/**\r\n * Find which rhyme group has issues and which lines to highlight\r\n */\r\nfunction getRhymeErrorLines(analysis: SonnetAnalysis): Set<number> {\r\n  const errorLines = new Set<number>();\r\n  \r\n  // Check each rhyme group\r\n  for (const [letter, lineIndices] of Object.entries(analysis.rhymeGroups)) {\r\n    if (lineIndices.length <= 1) continue; // Skip single-line groups\r\n    \r\n    // Get rhyme keys for this group\r\n    const rhymeKeys = lineIndices.map(i => analysis.lines[i].rhymeKey);\r\n    const validRhymes = rhymeKeys.filter(r => r !== '');\r\n    const uniqueRhymes = new Set(validRhymes);\r\n    \r\n    // If there are mismatches, use first line's rhyme as baseline\r\n    if (uniqueRhymes.size > 1) {\r\n      const rhymeCounts = new Map<string, number[]>();\r\n      lineIndices.forEach((lineIdx, i) => {\r\n        const key = rhymeKeys[i];\r\n        if (!rhymeCounts.has(key)) {\r\n          rhymeCounts.set(key, []);\r\n        }\r\n        rhymeCounts.get(key)!.push(lineIdx);\r\n      });\r\n      \r\n      // Determine baseline rhyme: use first line's rhyme, or most common if first is empty\r\n      let baselineRhyme = rhymeKeys[0];\r\n      if (baselineRhyme === '') {\r\n        // First line has no rhyme, find the most common rhyme\r\n        let maxCount = 0;\r\n        for (const [key, lines] of rhymeCounts.entries()) {\r\n          if (key !== '' && lines.length > maxCount) {\r\n            maxCount = lines.length;\r\n            baselineRhyme = key;\r\n          }\r\n        }\r\n      }\r\n      \r\n      // Mark all lines that don't match the baseline as errors\r\n      lineIndices.forEach((lineIdx, i) => {\r\n        if (rhymeKeys[i] !== baselineRhyme) {\r\n          errorLines.add(lineIdx);\r\n        }\r\n      });\r\n    }\r\n  }\r\n  \r\n  return errorLines;\r\n}\r\n\r\n/**\r\n * Render a single line with syllable highlighting\r\n */\r\nfunction renderLine(line: LineAnalysis, rhymeLetter: string, analysis: SonnetAnalysis, rhymeErrorLines: Set<number>): HTMLElement {\r\n  const lineDiv = document.createElement('div');\r\n  lineDiv.className = 'line';\r\n  \r\n  // Check if this line has meter issues (skip lines with too few/many syllables)\r\n  const shouldCheckMeter = line.words.length > 0 && \r\n    Math.abs(line.stressPattern.length - (line.expectedStressPattern?.length || 10)) <= 2;\r\n  \r\n  if (shouldCheckMeter && !line.meterValid) {\r\n    lineDiv.classList.add('meter-invalid');\r\n  }\r\n\r\n  // Line number\r\n  const lineNumber = document.createElement('span');\r\n  lineNumber.className = 'line-number';\r\n  lineNumber.textContent = `${line.lineNumber}.`;\r\n  lineDiv.appendChild(lineNumber);\r\n\r\n  // Render each word with syllables\r\n  for (const word of line.words) {\r\n    const wordSpan = document.createElement('span');\r\n    wordSpan.className = 'word';\r\n\r\n    if (word.found && word.syllables.length > 0) {\r\n      // Get syllable boundaries for the word\r\n      const syllableBoundaries = dictionary.syllabifyWord(word.originalWord, word.syllables);\r\n      const wordText = word.originalWord;\r\n      \r\n      // Calculate global syllable index for meter checking\r\n      let globalSyllableIndex = 0;\r\n      for (const w of line.words) {\r\n        if (w === word) break;\r\n        globalSyllableIndex += w.syllables.length;\r\n      }\r\n      \r\n      // Render each syllable part separately\r\n      for (let i = 0; i < word.syllables.length; i++) {\r\n        const syllable = word.syllables[i];\r\n        const [start, end] = syllableBoundaries[i] || [0, wordText.length - 1];\r\n        const syllableText = wordText.substring(start, end + 1);\r\n        \r\n        // Determine stress class - only apply color to stressed syllables\r\n        let stressClass = 'stress-0';\r\n        if (syllable.stress === 1) {\r\n          stressClass = 'stress-1';\r\n        } else if (syllable.stress === 2) {\r\n          stressClass = 'stress-2';\r\n        }\r\n        \r\n        const syllableSpan = document.createElement('span');\r\n        syllableSpan.className = `syllable ${stressClass}`;\r\n        syllableSpan.textContent = syllableText;\r\n        \r\n        // Check meter pattern and mark correct/incorrect stresses\r\n        // Always check if expectedStressPattern exists, regardless of line validity\r\n        if (line.expectedStressPattern) {\r\n          const expectedIndex = globalSyllableIndex + i;\r\n          if (expectedIndex < line.expectedStressPattern.length) {\r\n            const expected = line.expectedStressPattern[expectedIndex];\r\n            const actual = syllable.stress;\r\n            \r\n            // Mark based on position and stress combination\r\n            if (expected === 1) {\r\n              // Heavy position (should have stress)\r\n              if (actual === 1) {\r\n                // Primary stress in heavy position - dark green\r\n                syllableSpan.classList.add('meter-correct');\r\n              } else if (actual === 2) {\r\n                // Secondary stress in heavy position - light green\r\n                syllableSpan.classList.add('meter-correct-secondary');\r\n              } else if (actual === 0) {\r\n                // No stress in heavy position - error! (black text with red background)\r\n                if (shouldCheckMeter && !line.meterValid) {\r\n                  syllableSpan.classList.add('meter-error');\r\n                }\r\n              }\r\n            }\r\n            // Light position (expected === 0): keep default colors\r\n            // - stress 0 in light position: black (correct)\r\n            // - stress 1/2 in light position: yellow/orange (default stress colors)\r\n          }\r\n        }\r\n        \r\n        syllableSpan.title = `Syllable ${i + 1}/${word.syllables.length}, Stress: ${syllable.stress}`;\r\n        wordSpan.appendChild(syllableSpan);\r\n      }\r\n      \r\n      // Add overall word tooltip\r\n      wordSpan.title = `Syllables: ${word.syllables.length}, Stress pattern: ${word.syllables.map(s => s.stress).join('')}`;\r\n    } else {\r\n      // Word not found in dictionary - show with estimated stress pattern\r\n      const notFoundSpan = document.createElement('span');\r\n      notFoundSpan.className = 'word-not-found';\r\n      \r\n      // Display word with estimated stress markers (similar to CMU format)\r\n      const stressPattern = word.syllables.map(s => s.stress).join('');\r\n      notFoundSpan.textContent = word.originalWord;\r\n      \r\n      // Create a tooltip showing the estimated pronunciation\r\n      const estimatedPronunciation = word.syllables.map((s, i) => {\r\n        const syllableNum = i + 1;\r\n        return `[syllable${syllableNum}:${s.stress}]`;\r\n      }).join(' ');\r\n      \r\n      notFoundSpan.title = `Word not in dictionary\\nEstimated: ${word.syllables.length} syllable${word.syllables.length !== 1 ? 's' : ''}\\nStress pattern: ${stressPattern}\\n${estimatedPronunciation}`;\r\n      wordSpan.appendChild(notFoundSpan);\r\n    }\r\n\r\n    lineDiv.appendChild(wordSpan);\r\n    lineDiv.appendChild(document.createTextNode(' '));\r\n  }\r\n\r\n  // Add rhyme marker with color and optional error highlight\r\n  const rhymeMarker = document.createElement('span');\r\n  rhymeMarker.className = 'rhyme-marker';\r\n  rhymeMarker.textContent = rhymeLetter;\r\n  rhymeMarker.style.color = getRhymeColor(rhymeLetter);\r\n  \r\n  // Highlight rhyme marker if this line has a rhyme error\r\n  if (rhymeErrorLines.has(line.lineNumber - 1)) {\r\n    rhymeMarker.classList.add('rhyme-error');\r\n  }\r\n  \r\n  lineDiv.appendChild(rhymeMarker);\r\n\r\n  // Add line text as tooltip\r\n  lineDiv.title = line.text;\r\n\r\n  return lineDiv;\r\n}\r\n\r\n/**\r\n * Render the complete analysis\r\n */\r\nfunction renderAnalysis(analysis: SonnetAnalysis): void {\r\n  output.innerHTML = '';\r\n\r\n  // Check for unknown words and show warning\r\n  const unknownWords = new Set<string>();\r\n  for (const line of analysis.lines) {\r\n    for (const word of line.words) {\r\n      if (!word.found) {\r\n        unknownWords.add(word.originalWord);\r\n      }\r\n    }\r\n  }\r\n\r\n  // Show warning if there are unknown words\r\n  if (unknownWords.size > 0) {\r\n    const warning = document.createElement('div');\r\n    warning.className = 'warning-box';\r\n    warning.innerHTML = `\r\n      <strong>⚠️ Words not in dictionary:</strong> \r\n      ${Array.from(unknownWords).join(', ')}\r\n      <br><small>Analysis may be less accurate. Syllable counts and rhymes are estimated.</small>\r\n    `;\r\n    output.appendChild(warning);\r\n  }\r\n\r\n  // Get rhyme error lines\r\n  const rhymeErrorLines = getRhymeErrorLines(analysis);\r\n\r\n  // Render lines\r\n  const linesContainer = document.createElement('div');\r\n  analysis.lines.forEach((line, index) => {\r\n    const rhymeLetter = analysis.form.rhymeScheme[index] || '?';\r\n    const lineElement = renderLine(line, rhymeLetter, analysis, rhymeErrorLines);\r\n    linesContainer.appendChild(lineElement);\r\n  });\r\n  output.appendChild(linesContainer);\r\n\r\n  // Render summary\r\n  const summary = document.createElement('div');\r\n  summary.className = 'summary';\r\n\r\n  const summaryTitle = document.createElement('h3');\r\n  summaryTitle.textContent = 'Analysis Summary';\r\n  summary.appendChild(summaryTitle);\r\n\r\n  // Form info\r\n  const formInfo = document.createElement('div');\r\n  formInfo.className = 'summary-item';\r\n  formInfo.innerHTML = `<strong>Form:</strong> ${analysis.form.name}<br>\r\n                        <strong>Expected Meter:</strong> ${analysis.form.meter.name} (${analysis.form.meter.description})<br>\r\n                        <strong>Expected Rhyme Scheme:</strong> ${analysis.form.rhymeScheme.join('')}`;\r\n  summary.appendChild(formInfo);\r\n\r\n  // Meter validation\r\n  const meterItem = document.createElement('div');\r\n  meterItem.className = `summary-item ${analysis.meterValid ? 'valid' : 'invalid'}`;\r\n  meterItem.innerHTML = `<strong>Meter:</strong> ${analysis.meterValid ? '✓ Valid' : '✗ Issues Found'}`;\r\n  \r\n  if (!analysis.meterValid && analysis.meterIssues.length > 0) {\r\n    analysis.meterIssues.forEach(issue => {\r\n      const issueDiv = document.createElement('div');\r\n      issueDiv.className = 'issue';\r\n      issueDiv.textContent = issue;\r\n      meterItem.appendChild(issueDiv);\r\n    });\r\n  }\r\n  summary.appendChild(meterItem);\r\n\r\n  // Rhyme scheme validation\r\n  const rhymeItem = document.createElement('div');\r\n  rhymeItem.className = `summary-item ${analysis.rhymeSchemeValid ? 'valid' : 'invalid'}`;\r\n  rhymeItem.innerHTML = `<strong>Rhyme Scheme:</strong> ${analysis.rhymeSchemeValid ? '✓ Valid' : '✗ Issues Found'}`;\r\n  \r\n  if (!analysis.rhymeSchemeValid && analysis.rhymeIssues.length > 0) {\r\n    analysis.rhymeIssues.forEach(issue => {\r\n      const issueDiv = document.createElement('div');\r\n      issueDiv.className = 'issue';\r\n      issueDiv.textContent = issue;\r\n      rhymeItem.appendChild(issueDiv);\r\n    });\r\n  }\r\n  summary.appendChild(rhymeItem);\r\n\r\n  output.appendChild(summary);\r\n}\r\n\r\n/**\r\n * Handle analyze button click\r\n */\r\nanalyzeBtn.addEventListener('click', () => {\r\n  const text = poemInput.value.trim();\r\n\r\n  if (!text) {\r\n    alert('Please enter a sonnet to analyze.');\r\n    return;\r\n  }\r\n\r\n  if (!dictionaryLoaded) {\r\n    alert('Dictionary is still loading. Please wait a moment and try again.');\r\n    return;\r\n  }\r\n\r\n  if (!currentForm) {\r\n    alert('Please select a poetic form.');\r\n    return;\r\n  }\r\n\r\n  try {\r\n    const analysis = analyzer.analyzeSonnet(text, currentForm, {\r\n      strict: meterMode.value === 'strict',\r\n      intelligent: intelligentMode.checked\r\n    });\r\n    renderAnalysis(analysis);\r\n  } catch (error) {\r\n    console.error('Analysis error:', error);\r\n    output.innerHTML = `<p style=\"color: red;\">Error analyzing sonnet: ${error}</p>`;\r\n  }\r\n});\r\n\r\n// Clear button handler\r\nclearBtn.addEventListener('click', () => {\r\n  poemInput.value = '';\r\n  output.innerHTML = '<p style=\"color: #999; font-style: italic;\">Enter a sonnet and click \"Analyze Sonnet\" to see the results.</p>';\r\n});\r\n\r\n// Load sample sonnet\r\nconst sampleSonnet = `Shall I compare thee to a summer's day\r\nThou art more lovely and more temperate\r\nRough winds do shake the darling buds of May\r\nAnd summer's lease hath all too short a date\r\nSometime too hot the eye of heaven shines\r\nAnd often is his gold complexion dimmed\r\nAnd every fair from fair sometime declines\r\nBy chance or nature's changing course untrimmed\r\nBut thy eternal summer shall not fade\r\nNor lose possession of that fair thou owest\r\nNor shall death brag thou wanderest in his shade\r\nWhen in eternal lines to time thou grow\r\nSo long as men can breathe or eyes can see\r\nSo long lives this and this gives life to thee`;\r\n\r\npoemInput.value = sampleSonnet;\r\n\r\nconsole.log('Sonnet Checker loaded successfully!');\r\n"],"names":["tokenizeLine","line","word","removePunctuation","SonnetAnalyzer","dictionary","lineText","lineNumber","expectedPattern","words","wordAnalyses","stressPattern","preliminaryAnalyses","cleaned","allPronunciations","analysis","options","phonemes","syllables","rhymeKey","hasMultipleOptions","w","wordData","syllable","bestCombination","i","wordOptions","result","currentPosition","bestOption","bestScore","option","score","syllableCount","globalPos","expected","actual","remainingSlots","meterType","strict","skip","fitted","_","insert","lines","expectedScheme","rhymeGroups","rhymeKeys","issues","letter","lineIndices","rhymes","validRhymes","r","uniqueRhymes","text","form","lineAnalyses","index","rhymeValidation","meterIssues","DictionaryService","analyzer","dictionaryLoaded","currentLanguage","currentForm","isTauri","loadDictionary","languageCode","dictionaryData","language","SUPPORTED_LANGUAGES","lang","response","dictionaryUrl","getDictionaryUrl","error","languageSelect","poemInput","sonnetForm","meterMode","intelligentMode","analyzeBtn","clearBtn","output","initLanguageSelector","updateFormSelector","newLanguage","formId","getRhymeColor","getRhymeErrorLines","errorLines","rhymeCounts","lineIdx","key","baselineRhyme","maxCount","renderLine","rhymeLetter","rhymeErrorLines","lineDiv","shouldCheckMeter","wordSpan","syllableBoundaries","wordText","globalSyllableIndex","start","end","syllableText","stressClass","syllableSpan","expectedIndex","s","notFoundSpan","estimatedPronunciation","rhymeMarker","renderAnalysis","unknownWords","warning","linesContainer","lineElement","summary","summaryTitle","formInfo","meterItem","issue","issueDiv","rhymeItem","sampleSonnet"],"mappings":"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"}