{"version":3,"file":"index-Dnh9ICHH.js","sources":["../../src/dictionary.ts","../../src/textProcessor.ts","../../src/analyzer.ts","../../src/config.ts","../../src/main.ts"],"sourcesContent":["import type { PronunciationDict, Syllable, WordAnalysis } from './types';\r\n\r\n/**\r\n * Dictionary service for loading and querying pronunciation data\r\n */\r\nexport class DictionaryService {\r\n  private dict: PronunciationDict = {};\r\n  private currentLanguage: string = 'en'; // 当前加载的语言\r\n  private customDict: PronunciationDict = {}; // 用户自定义词典\r\n\r\n  /**\r\n   * Load pronunciation dictionary from JSON data\r\n   */\r\n  async loadDictionary(dictData: PronunciationDict, languageCode: string = 'en'): Promise<void> {\r\n    this.dict = dictData;\r\n    this.currentLanguage = languageCode;\r\n    // Load custom dictionary from localStorage if available\r\n    this.loadCustomDictionary();\r\n  }\r\n\r\n  /**\r\n   * Load custom dictionary from localStorage\r\n   */\r\n  private loadCustomDictionary(): void {\r\n    try {\r\n      const stored = localStorage.getItem(`customDict_${this.currentLanguage}`);\r\n      if (stored) {\r\n        this.customDict = JSON.parse(stored);\r\n        console.log(`Loaded ${Object.keys(this.customDict).length} custom words`);\r\n      }\r\n    } catch (error) {\r\n      console.error('Failed to load custom dictionary:', error);\r\n      this.customDict = {};\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Save custom dictionary to localStorage\r\n   */\r\n  private saveCustomDictionary(): void {\r\n    try {\r\n      localStorage.setItem(\r\n        `customDict_${this.currentLanguage}`,\r\n        JSON.stringify(this.customDict)\r\n      );\r\n    } catch (error) {\r\n      console.error('Failed to save custom dictionary:', error);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Add a custom word pronunciation\r\n   */\r\n  addCustomWord(word: string, phonemes: string[]): void {\r\n    const normalized = word.toLowerCase().replace(/[^a-z']/g, '');\r\n    this.customDict[normalized] = [phonemes];\r\n    this.saveCustomDictionary();\r\n  }\r\n\r\n  /**\r\n   * Get current language code\r\n   */\r\n  getCurrentLanguage(): string {\r\n    return this.currentLanguage;\r\n  }\r\n\r\n  /**\r\n   * Look up a word in the dictionary\r\n   * Returns the first pronunciation if multiple exist\r\n   * Checks custom dictionary first, then main dictionary\r\n   */\r\n  lookup(word: string): string[] | null {\r\n    const normalized = word.toLowerCase().replace(/[^a-z']/g, '');\r\n    \r\n    // Check custom dictionary first\r\n    if (this.customDict[normalized]?.length > 0) {\r\n      return this.customDict[normalized][0];\r\n    }\r\n    \r\n    // Then check main dictionary\r\n    const pronunciations = this.dict[normalized];\r\n    if (!pronunciations || pronunciations.length === 0) {\r\n      return null;\r\n    }\r\n    return pronunciations[0]; // Return first pronunciation\r\n  }\r\n\r\n  /**\r\n   * Extract syllables from phonemes\r\n   * A syllable contains one vowel sound (phonemes ending in 0, 1, or 2)\r\n   */\r\n  extractSyllables(phonemes: string[]): Syllable[] {\r\n    const syllables: Syllable[] = [];\r\n    let currentSyllable: string[] = [];\r\n    let currentStress: 0 | 1 | 2 = 0;\r\n\r\n    for (const phoneme of phonemes) {\r\n      currentSyllable.push(phoneme);\r\n      \r\n      // Check if this phoneme contains stress information (ends with 0, 1, or 2)\r\n      const stressMatch = phoneme.match(/[012]$/);\r\n      if (stressMatch) {\r\n        currentStress = parseInt(stressMatch[0]) as 0 | 1 | 2;\r\n        syllables.push({\r\n          phonemes: currentSyllable,\r\n          stress: currentStress\r\n        });\r\n        currentSyllable = [];\r\n        currentStress = 0;\r\n      }\r\n    }\r\n\r\n    // Add any remaining consonants to the last syllable\r\n    if (currentSyllable.length > 0 && syllables.length > 0) {\r\n      syllables[syllables.length - 1].phonemes.push(...currentSyllable);\r\n    }\r\n\r\n    return syllables;\r\n  }\r\n\r\n  /**\r\n   * Extract rhyme key from phonemes\r\n   * The rhyme key consists of phonemes from the last primary stressed vowel to the end\r\n   */\r\n  extractRhymeKey(phonemes: string[]): string {\r\n    // Find the last vowel (phoneme with stress marker 0, 1, or 2)\r\n    let lastVowelIndex = -1;\r\n    for (let i = phonemes.length - 1; i >= 0; i--) {\r\n      if (phonemes[i].match(/[012]$/)) {\r\n        lastVowelIndex = i;\r\n        break;\r\n      }\r\n    }\r\n\r\n    if (lastVowelIndex === -1) {\r\n      // No vowel found in this word (all consonants), return empty\r\n      // The caller should look for the previous vowel in the line\r\n      return '';\r\n    }\r\n\r\n    // Return from last vowel to end, removing stress markers\r\n    return phonemes\r\n      .slice(lastVowelIndex)\r\n      .map(p => p.replace(/[012]$/, ''))\r\n      .join('-');\r\n  }\r\n\r\n  /**\r\n   * Heuristic syllable count for unknown words\r\n   * Based on vowel groups and English pronunciation rules\r\n   * For other languages, this method should be overridden\r\n   */\r\n  private estimateSyllables(word: string): number {\r\n    if (this.currentLanguage === 'en') {\r\n      return this.estimateSyllablesEnglish(word);\r\n    }\r\n    // For other languages, add specific methods\r\n    // else if (this.currentLanguage === 'la') return this.estimateSyllablesLatin(word);\r\n    return this.estimateSyllablesEnglish(word); // Default fallback\r\n  }\r\n\r\n  /**\r\n   * Advanced English syllable estimation\r\n   * Implements comprehensive rules for better accuracy\r\n   */\r\n  private estimateSyllablesEnglish(word: string): number {\r\n    const lower = word.toLowerCase().replace(/[^a-z]/g, '');\r\n    if (lower.length === 0) return 1;\r\n    \r\n    // Special cases - common words with irregular syllabification\r\n    const specialCases: { [key: string]: number } = {\r\n      // Single syllable despite multiple vowels\r\n      'are': 1, 'were': 1, 'where': 1, 'here': 1, 'there': 1,\r\n      'fire': 1, 'hour': 1, 'our': 1, 'your': 1,\r\n      'through': 1, 'though': 1, 'thought': 1, 'brought': 1,\r\n      'sure': 1, 'pure': 1, 'cure': 1,\r\n      \r\n      // Two syllables\r\n      'every': 2, 'prayer': 2, 'player': 2, 'layer': 2,\r\n      'being': 2, 'seeing': 2, 'doing': 2, 'going': 2,\r\n      \r\n      // Three syllables\r\n      'family': 3, 'library': 3, 'different': 3,\r\n      \r\n      // Common archaic/poetic words\r\n      'thee': 1, 'thou': 1, 'thy': 1, 'thine': 1,\r\n      'hath': 1, 'doth': 1, 'shalt': 1, 'wilt': 1,\r\n      'ere': 1, 'oft': 1, 'nigh': 1,\r\n      'oer': 1, 'eer': 1, 'neer': 1, // o'er, e'er, ne'er\r\n      'tis': 1, 'twas': 1, 'twere': 1,\r\n    };\r\n    \r\n    if (specialCases[lower]) {\r\n      return specialCases[lower];\r\n    }\r\n    \r\n    let count = 0;\r\n    const vowels = 'aeiouy';\r\n    let previousWasVowel = false;\r\n    \r\n    // Count vowel groups\r\n    for (let i = 0; i < lower.length; i++) {\r\n      const char = lower[i];\r\n      const isVowel = vowels.includes(char);\r\n      \r\n      if (isVowel && !previousWasVowel) {\r\n        count++;\r\n      }\r\n      previousWasVowel = isVowel;\r\n    }\r\n    \r\n    // Apply English-specific rules\r\n    \r\n    // Rule 1: Silent 'e' at the end\r\n    if (lower.endsWith('e')) {\r\n      // But not after certain patterns\r\n      if (count > 1 && !lower.match(/(le|re|ne|me|he|se|ze|ve|de|ge|te|ce|pe)$/)) {\r\n        count--;\r\n      }\r\n      // Exceptions: -le, -tle, -ble, -ple, etc. after consonant\r\n      if (lower.match(/[^aeiou]le$/)) {\r\n        // 'le' after consonant adds a syllable (e.g., \"table\" = 2)\r\n        // Already counted correctly, do nothing\r\n      }\r\n    }\r\n    \r\n    // Rule 2: -ed ending\r\n    if (lower.endsWith('ed')) {\r\n      // Usually doesn't add syllable except after 'd' or 't'\r\n      if (!lower.match(/[dt]ed$/)) {\r\n        count--;\r\n      }\r\n    }\r\n    \r\n    // Rule 3: -es ending\r\n    if (lower.endsWith('es') && lower.length > 2) {\r\n      const beforeEs = lower.slice(-3, -2);\r\n      // -es adds syllable after s, z, x, ch, sh (e.g., \"boxes\", \"wishes\")\r\n      if (!'szx'.includes(beforeEs) && !lower.endsWith('ches') && !lower.endsWith('shes')) {\r\n        count--;\r\n      }\r\n    }\r\n    \r\n    // Rule 4: -ing, -ting, -ding usually don't add extra syllable\r\n    // (already handled by vowel counting, but verify)\r\n    \r\n    // Rule 5: Diphthongs that should be one syllable\r\n    // ea, ee, oo, ou, oi, ay, ey, ow are usually one vowel sound\r\n    // (already handled by consecutive vowel grouping)\r\n    \r\n    // Rule 6: -tion, -sion, -cion endings\r\n    if (lower.match(/(tion|sion|cion)$/)) {\r\n      // These are usually 2 syllables: -ti-on, -si-on\r\n      // The 'io' is counted as one vowel group, but should be 2\r\n      count++;\r\n    }\r\n    \r\n    // Rule 7: -ious, -eous endings\r\n    if (lower.match(/(ious|eous)$/)) {\r\n      // e.g., \"curious\" = 3, \"gorgeous\" = 2\r\n      // 'ious' has 2 syllable sounds despite consecutive vowels\r\n      count++;\r\n    }\r\n    \r\n    // Rule 8: -ia, -iu, -io at the end often form separate syllable\r\n    if (lower.match(/(ia|iu|io)$/) && lower.length > 3) {\r\n      // e.g., \"California\" - 'ia' is separate\r\n      const before = lower[lower.length - 3];\r\n      if (!vowels.includes(before)) {\r\n        count++;\r\n      }\r\n    }\r\n    \r\n    // Rule 9: Three+ consecutive vowels might be multiple syllables\r\n    const tripleVowelMatch = lower.match(/[aeiouy]{3,}/g);\r\n    if (tripleVowelMatch) {\r\n      for (const match of tripleVowelMatch) {\r\n        // \"beautiful\" has \"eau\" but it's 1 syllable in that context\r\n        // Add logic for specific patterns if needed\r\n      }\r\n    }\r\n    \r\n    // Rule 10: Y between consonants acts as vowel\r\n    // (already handled by including 'y' in vowels)\r\n    \r\n    return Math.max(1, count); // At least 1 syllable\r\n  }\r\n\r\n  /**\r\n   * Create fallback analysis for unknown words\r\n   * Attempts to guess stress patterns based on English rules\r\n   */\r\n  private createFallbackAnalysis(word: string): WordAnalysis {\r\n    const syllableCount = this.estimateSyllables(word);\r\n    const syllables: Syllable[] = [];\r\n    \r\n    // Guess stress position based on syllable count and word patterns\r\n    let stressPosition = 0; // Which syllable gets primary stress (0-indexed)\r\n    \r\n    if (syllableCount === 1) {\r\n      stressPosition = 0;\r\n    } else if (syllableCount === 2) {\r\n      // For 2-syllable words, stress is often on first syllable\r\n      // But suffixes like -tion, -ment, -ly shift stress earlier\r\n      const lower = word.toLowerCase();\r\n      if (lower.match(/(ment|ness|less|ful|ly)$/)) {\r\n        stressPosition = 0; // Stress before suffix\r\n      } else if (lower.match(/(tion|sion|ic)$/)) {\r\n        stressPosition = 0; // Stress before -tion\r\n      } else {\r\n        stressPosition = 0; // Default: first syllable\r\n      }\r\n    } else if (syllableCount >= 3) {\r\n      // For 3+ syllable words, stress is often on first or second syllable\r\n      const lower = word.toLowerCase();\r\n      if (lower.match(/(tion|sion)$/)) {\r\n        stressPosition = Math.max(0, syllableCount - 3); // Before -tion\r\n      } else if (lower.match(/(ic|ical)$/)) {\r\n        stressPosition = Math.max(0, syllableCount - 3); // Before -ic\r\n      } else if (lower.match(/(ity|ety)$/)) {\r\n        stressPosition = Math.max(0, syllableCount - 3); // Before -ity\r\n      } else {\r\n        stressPosition = Math.min(1, syllableCount - 1); // Second syllable or first\r\n      }\r\n    }\r\n    \r\n    // Create syllable structure\r\n    for (let i = 0; i < syllableCount; i++) {\r\n      const stress: 0 | 1 | 2 = \r\n        i === stressPosition ? 1 : // Primary stress\r\n        0;                          // Unstressed\r\n      \r\n      syllables.push({\r\n        phonemes: [],\r\n        stress\r\n      });\r\n    }\r\n    \r\n    // Create a basic rhyme key from the last 2-3 characters\r\n    const rhymeKey = word.length >= 2 ? \r\n      word.slice(-2).toLowerCase() : \r\n      word.toLowerCase();\r\n    \r\n    return {\r\n      word: word.toLowerCase(),\r\n      originalWord: word,\r\n      syllables,\r\n      rhymeKey,\r\n      found: false\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Map phonemes to letter positions in the word\r\n   * Returns array of letter ranges for each syllable: [startIdx, endIdx]\r\n   */\r\n  syllabifyWord(word: string, syllables: Syllable[]): Array<[number, number]> {\r\n    const lower = word.toLowerCase();\r\n    const vowels = 'aeiouy';\r\n    const result: Array<[number, number]> = [];\r\n    \r\n    // Find all vowel positions in the word\r\n    const vowelPositions: number[] = [];\r\n    for (let i = 0; i < lower.length; i++) {\r\n      if (vowels.includes(lower[i])) {\r\n        vowelPositions.push(i);\r\n      }\r\n    }\r\n    \r\n    if (vowelPositions.length === 0 || syllables.length === 0) {\r\n      // No vowels or syllables, return whole word as one unit\r\n      return [[0, word.length - 1]];\r\n    }\r\n    \r\n    // If syllable count doesn't match vowel count, use simple division\r\n    if (syllables.length !== vowelPositions.length) {\r\n      // Fallback: divide word evenly\r\n      const avgLength = word.length / syllables.length;\r\n      for (let i = 0; i < syllables.length; i++) {\r\n        const start = Math.floor(i * avgLength);\r\n        const end = i === syllables.length - 1 ? word.length - 1 : Math.floor((i + 1) * avgLength) - 1;\r\n        result.push([start, end]);\r\n      }\r\n      return result;\r\n    }\r\n    \r\n    // Apply syllabification rules based on consonants between vowels\r\n    for (let i = 0; i < vowelPositions.length; i++) {\r\n      const vowelPos = vowelPositions[i];\r\n      let start: number;\r\n      let end: number;\r\n      \r\n      if (i === 0) {\r\n        // First syllable: starts from beginning\r\n        start = 0;\r\n      } else {\r\n        // Find consonants between this vowel and previous vowel\r\n        const prevVowel = vowelPositions[i - 1];\r\n        const consonantCount = vowelPos - prevVowel - 1;\r\n        \r\n        if (consonantCount === 0) {\r\n          // Two vowels adjacent: split between them\r\n          start = vowelPos;\r\n        } else if (consonantCount === 1) {\r\n          // One consonant: goes to current syllable\r\n          start = prevVowel + 1;\r\n        } else if (consonantCount === 2) {\r\n          // Two consonants: split 1+1\r\n          start = prevVowel + 2;\r\n        } else if (consonantCount === 3) {\r\n          // Three consonants: split 2+1\r\n          start = prevVowel + 3;\r\n        } else {\r\n          // Four or more: split evenly\r\n          const half = Math.floor(consonantCount / 2);\r\n          start = prevVowel + 1 + half;\r\n        }\r\n      }\r\n      \r\n      if (i === vowelPositions.length - 1) {\r\n        // Last syllable: goes to end\r\n        end = word.length - 1;\r\n      } else {\r\n        // Find split point with next syllable\r\n        const nextVowel = vowelPositions[i + 1];\r\n        const consonantCount = nextVowel - vowelPos - 1;\r\n        \r\n        if (consonantCount === 0) {\r\n          // Two vowels adjacent: include current vowel only\r\n          end = vowelPos;\r\n        } else if (consonantCount === 1) {\r\n          // One consonant: include current vowel only\r\n          end = vowelPos;\r\n        } else if (consonantCount === 2) {\r\n          // Two consonants: split 1+1, take first consonant\r\n          end = vowelPos + 1;\r\n        } else if (consonantCount === 3) {\r\n          // Three consonants: split 2+1, take first two\r\n          end = vowelPos + 2;\r\n        } else {\r\n          // Four or more: take half\r\n          const half = Math.floor(consonantCount / 2);\r\n          end = vowelPos + half;\r\n        }\r\n      }\r\n      \r\n      result.push([start, end]);\r\n    }\r\n    \r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Analyze a single word\r\n   */\r\n  analyzeWord(word: string): WordAnalysis {\r\n    const phonemes = this.lookup(word);\r\n    \r\n    if (!phonemes) {\r\n      // Use fallback analysis for unknown words\r\n      return this.createFallbackAnalysis(word);\r\n    }\r\n\r\n    const syllables = this.extractSyllables(phonemes);\r\n    const rhymeKey = this.extractRhymeKey(phonemes);\r\n\r\n    return {\r\n      word: word.toLowerCase(),\r\n      originalWord: word,\r\n      syllables,\r\n      rhymeKey,\r\n      found: true\r\n    };\r\n  }\r\n}\r\n","/**\r\n * Text processing utilities for preprocessing sonnet input\r\n */\r\n\r\n/**\r\n * Split text into lines, preserving empty lines\r\n */\r\nexport function splitLines(text: string): string[] {\r\n  return text.split('\\n');\r\n}\r\n\r\n/**\r\n * Tokenize a line into words\r\n * Preserves the original words before removing punctuation\r\n */\r\nexport function tokenizeLine(line: string): string[] {\r\n  // Split on whitespace and filter empty strings\r\n  return line.trim().split(/\\s+/).filter(word => word.length > 0);\r\n}\r\n\r\n/**\r\n * Remove punctuation from a word but preserve apostrophes\r\n * for contractions like \"it's\" or \"don't\"\r\n */\r\nexport function removePunctuation(word: string): string {\r\n  // First normalize all apostrophe variants to ASCII apostrophe\r\n  const normalized = word.replace(/['']/g, \"'\");\r\n  // Keep letters and apostrophes, remove everything else\r\n  return normalized.replace(/[^a-zA-Z']/g, '');\r\n}\r\n\r\n/**\r\n * Preprocess text: split lines and tokenize\r\n */\r\nexport function preprocessText(text: string): { lines: string[], tokens: string[][] } {\r\n  const lines = splitLines(text);\r\n  const tokens = lines.map(line => tokenizeLine(line));\r\n  return { lines, tokens };\r\n}\r\n","import type {\r\n  LineAnalysis,\r\n  SonnetAnalysis,\r\n  SonnetForm,\r\n  StressPattern,\r\n  WordAnalysis\r\n} from './types';\r\nimport { DictionaryService } from './dictionary';\r\nimport { tokenizeLine, removePunctuation } from './textProcessor';\r\n\r\n/**\r\n * Sonnet analyzer service\r\n */\r\nexport class SonnetAnalyzer {\r\n  constructor(private dictionary: DictionaryService) {}\r\n\r\n  /**\r\n   * Analyze a single line of text\r\n   */\r\n  analyzeLine(lineText: string, lineNumber: number): LineAnalysis {\r\n    const words = tokenizeLine(lineText);\r\n    const wordAnalyses: WordAnalysis[] = [];\r\n    const stressPattern: StressPattern = [];\r\n\r\n    for (const word of words) {\r\n      const cleaned = removePunctuation(word);\r\n      if (!cleaned) continue;\r\n\r\n      const analysis = this.dictionary.analyzeWord(cleaned);\r\n      wordAnalyses.push(analysis);\r\n\r\n      // Build stress pattern from syllables\r\n      for (const syllable of analysis.syllables) {\r\n        stressPattern.push(syllable.stress);\r\n      }\r\n    }\r\n\r\n    // Get rhyme key from last word\r\n    const lastWord = wordAnalyses.length > 0 ? wordAnalyses[wordAnalyses.length - 1] : null;\r\n    let rhymeKey = lastWord?.rhymeKey || '';\r\n    \r\n    // If last word has no rhyme key (all consonants), look backward for last vowel in line\r\n    if (rhymeKey === '' && wordAnalyses.length > 0) {\r\n      for (let i = wordAnalyses.length - 1; i >= 0; i--) {\r\n        if (wordAnalyses[i].rhymeKey) {\r\n          rhymeKey = wordAnalyses[i].rhymeKey;\r\n          break;\r\n        }\r\n      }\r\n    }\r\n\r\n    return {\r\n      lineNumber,\r\n      text: lineText,\r\n      words: wordAnalyses,\r\n      stressPattern,\r\n      rhymeKey\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Check if stress pattern matches expected meter\r\n   * Returns true if valid, false if there are issues\r\n   * Rules vary by meter type (iambic, trochaic, etc.)\r\n   */\r\n  checkMeter(actual: StressPattern, expected: StressPattern, meterType: string = 'iambic'): boolean {\r\n    // If syllable count is way off (more than 2 syllables difference), skip checking\r\n    if (Math.abs(actual.length - expected.length) > 2) {\r\n      return false; // Will be handled as unchecked line\r\n    }\r\n\r\n    // Check if length matches\r\n    if (actual.length !== expected.length) {\r\n      return false;\r\n    }\r\n\r\n    // Apply checking rules based on meter type\r\n    if (meterType === 'iambic') {\r\n      return this.checkIambicMeter(actual, expected);\r\n    } else {\r\n      // For other meter types, use strict checking for now\r\n      return this.checkStrictMeter(actual, expected);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Iambic meter checking (抑扬格)\r\n   * Lenient: allows \"light→heavy\" (0→1), but flags:\r\n   * - \"heavy→light\" (1→0): wrong stress position\r\n   * - \"light→light\" (0→0) when expecting heavy (1): missing stress\r\n   */\r\n  private checkIambicMeter(actual: StressPattern, expected: StressPattern): boolean {\r\n    for (let i = 0; i < expected.length; i++) {\r\n      if (expected[i] === 1) {\r\n        // Expected stressed position\r\n        if (actual[i] === 0) {\r\n          // Got unstressed (0) when expecting stressed (1) - ERROR: \"轻轻\"\r\n          return false;\r\n        }\r\n        // Allow actual[i] === 1 (correct) or actual[i] === 2 (secondary stress, acceptable)\r\n      } else {\r\n        // Expected unstressed position (expected[i] === 0)\r\n        if (actual[i] === 1) {\r\n          // Got stressed (1) in unstressed position - ALLOWED for flexibility\r\n          // (单音节词可以轻读)\r\n          continue;\r\n        }\r\n        // actual[i] === 0 or 2 are both fine for unstressed positions\r\n      }\r\n    }\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Strict meter checking for non-iambic meters\r\n   * Requires exact match of stress pattern\r\n   */\r\n  private checkStrictMeter(actual: StressPattern, expected: StressPattern): boolean {\r\n    for (let i = 0; i < expected.length; i++) {\r\n      if (expected[i] === 1 && actual[i] !== 1) {\r\n        return false; // Expected primary stress, got something else\r\n      }\r\n      if (expected[i] === 0 && actual[i] === 1) {\r\n        return false; // Expected unstressed, got primary stress\r\n      }\r\n    }\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Validate rhyme scheme\r\n   */\r\n  validateRhymeScheme(lines: LineAnalysis[], expectedScheme: string[]): {\r\n    valid: boolean;\r\n    issues: string[];\r\n    rhymeGroups: { [letter: string]: number[] }; // Map rhyme letters to line indices\r\n  } {\r\n    const rhymeGroups: { [letter: string]: number[] } = {};\r\n    const rhymeKeys: { [letter: string]: string[] } = {};\r\n    const issues: string[] = [];\r\n\r\n    // Group lines by their rhyme scheme letter\r\n    for (let i = 0; i < Math.min(lines.length, expectedScheme.length); i++) {\r\n      const letter = expectedScheme[i];\r\n      const rhymeKey = lines[i].rhymeKey;\r\n\r\n      if (!rhymeGroups[letter]) {\r\n        rhymeGroups[letter] = [];\r\n        rhymeKeys[letter] = [];\r\n      }\r\n      rhymeGroups[letter].push(i);\r\n      rhymeKeys[letter].push(rhymeKey);\r\n    }\r\n\r\n    // Check that all lines in each rhyme group have the same rhyme key\r\n    for (const [letter, lineIndices] of Object.entries(rhymeGroups)) {\r\n      // Skip single-line rhyme groups (no checking needed)\r\n      if (lineIndices.length <= 1) {\r\n        continue;\r\n      }\r\n\r\n      const rhymes = rhymeKeys[letter];\r\n      const validRhymes = rhymes.filter(r => r !== '');\r\n      const uniqueRhymes = new Set(validRhymes);\r\n      \r\n      // Check if there are multiple different rhymes\r\n      if (uniqueRhymes.size > 1) {\r\n        issues.push(`Rhyme group ${letter} has inconsistent rhymes: ${Array.from(uniqueRhymes).join(', ')}`);\r\n      }\r\n      \r\n      // Check for missing rhyme keys (words not in dictionary)\r\n      if (validRhymes.length < rhymes.length) {\r\n        issues.push(`Rhyme group ${letter} contains words not found in dictionary`);\r\n      }\r\n    }\r\n\r\n    return {\r\n      valid: issues.length === 0,\r\n      issues,\r\n      rhymeGroups\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Analyze an entire sonnet\r\n   */\r\n  analyzeSonnet(text: string, form: SonnetForm): SonnetAnalysis {\r\n    const lines = text.split('\\n').filter(line => line.trim().length > 0);\r\n    \r\n    const lineAnalyses: LineAnalysis[] = lines.map((line, index) => {\r\n      const analysis = this.analyzeLine(line, index + 1);\r\n      \r\n      // Check meter\r\n      analysis.expectedStressPattern = form.meter.stressPattern;\r\n      analysis.meterValid = this.checkMeter(\r\n        analysis.stressPattern,\r\n        form.meter.stressPattern,\r\n        form.meter.type || 'iambic' // Default to iambic if not specified\r\n      );\r\n\r\n      return analysis;\r\n    });\r\n\r\n    // Validate rhyme scheme\r\n    const rhymeValidation = this.validateRhymeScheme(lineAnalyses, form.rhymeScheme);\r\n\r\n    // Check meter validity\r\n    const meterIssues: string[] = [];\r\n    for (const line of lineAnalyses) {\r\n      // Skip lines that are too far off or have no valid words\r\n      if (line.words.length === 0 || Math.abs(line.stressPattern.length - form.meter.stressPattern.length) > 2) {\r\n        continue;\r\n      }\r\n      \r\n      if (!line.meterValid) {\r\n        meterIssues.push(\r\n          `Line ${line.lineNumber}: Expected ${form.meter.stressPattern.length} syllables ` +\r\n          `with pattern ${form.meter.stressPattern.join('')}, ` +\r\n          `got ${line.stressPattern.length} syllables with pattern ${line.stressPattern.join('')}`\r\n        );\r\n      }\r\n    }\r\n\r\n    return {\r\n      lines: lineAnalyses,\r\n      form,\r\n      rhymeSchemeValid: rhymeValidation.valid,\r\n      meterValid: meterIssues.length === 0,\r\n      rhymeIssues: rhymeValidation.issues,\r\n      meterIssues,\r\n      rhymeGroups: rhymeValidation.rhymeGroups\r\n    };\r\n  }\r\n}\r\n","/**\r\n * 配置文件 - 管理外部资源路径和诗歌形式\r\n */\r\n\r\nimport type { LanguageConfig, SonnetForm, MeterPattern } from './types';\r\n\r\n// GitHub 仓库配置\r\nexport const GITHUB_CONFIG = {\r\n  // 开发仓库（存放源代码和数据文件）\r\n  devRepo: {\r\n    owner: 'ShioLilia',\r\n    name: 'sonnetaw',\r\n    branch: 'main'\r\n  },\r\n  \r\n  // 托管仓库（仅存放构建产物）\r\n  pagesRepo: {\r\n    owner: 'ShioLilia',\r\n    name: 'ShioLilia.github.io',\r\n    branch: 'main'\r\n  }\r\n};\r\n\r\n// 通用格律模式定义\r\nconst IAMBIC_PENTAMETER: MeterPattern = {\r\n  name: 'Iambic Pentameter',\r\n  description: 'Unstressed-stressed pattern, 10 syllables per line',\r\n  stressPattern: [0, 1, 0, 1, 0, 1, 0, 1, 0, 1],\r\n  syllableCount: 10,\r\n  type: 'iambic'\r\n};\r\n\r\nconst IAMBIC_HEXAMETER: MeterPattern = {\r\n  name: 'Iambic Hexameter',\r\n  description: 'Unstressed-stressed pattern, 12 syllables per line',\r\n  stressPattern: [0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1],\r\n  syllableCount: 12,\r\n  type: 'iambic'\r\n};\r\n\r\n// 英语诗歌形式\r\nconst ENGLISH_FORMS: SonnetForm[] = [\r\n  {\r\n    id: 'shakespearean',\r\n    name: 'Shakespearean Sonnet',\r\n    description: 'ABAB CDCD EFEF GG',\r\n    rhymeScheme: ['A', 'B', 'A', 'B', 'C', 'D', 'C', 'D', 'E', 'F', 'E', 'F', 'G', 'G'],\r\n    meter: IAMBIC_PENTAMETER,\r\n    lineCount: 14\r\n  },\r\n  {\r\n    id: 'petrarchan1',\r\n    name: 'Petrarchan Sonnet (CDECDE)',\r\n    description: 'ABBAABBA CDECDE',\r\n    rhymeScheme: ['A', 'B', 'B', 'A', 'A', 'B', 'B', 'A', 'C', 'D', 'E', 'C', 'D', 'E'],\r\n    meter: IAMBIC_PENTAMETER,\r\n    lineCount: 14\r\n  },\r\n  {\r\n    id: 'petrarchan2',\r\n    name: 'Petrarchan Sonnet (CDCDCD)',\r\n    description: 'ABBAABBA CDCDCD',\r\n    rhymeScheme: ['A', 'B', 'B', 'A', 'A', 'B', 'B', 'A', 'C', 'D', 'C', 'D', 'C', 'D'],\r\n    meter: IAMBIC_PENTAMETER,\r\n    lineCount: 14\r\n  }\r\n];\r\n\r\n// 支持的语言列表（包含各自的诗歌形式）\r\nexport const SUPPORTED_LANGUAGES: LanguageConfig[] = [\r\n  {\r\n    code: 'en',\r\n    name: 'English',\r\n    dictionaryFile: 'eng-cmu.json',\r\n    poeticForms: ENGLISH_FORMS\r\n  },\r\n  // 添加拉丁语示例：\r\n  // {\r\n  //   code: 'la',\r\n  //   name: 'Latin',\r\n  //   dictionaryFile: 'latin-prosody.json',\r\n  //   poeticForms: [\r\n  //     {\r\n  //       id: 'dactylic_hexameter',\r\n  //       name: 'Dactylic Hexameter',\r\n  //       description: 'Classical epic meter (Homer, Virgil)',\r\n  //       rhymeScheme: [], // No rhyme scheme\r\n  //       meter: DACTYLIC_HEXAMETER,\r\n  //       lineCount: 0 // Variable\r\n  //     },\r\n  //     {\r\n  //       id: 'elegiac_couplet',\r\n  //       name: 'Elegiac Couplet',\r\n  //       description: 'Hexameter + Pentameter',\r\n  //       rhymeScheme: [],\r\n  //       meter: ELEGIAC_METER,\r\n  //       lineCount: 2\r\n  //     }\r\n  //   ]\r\n  // },\r\n  // 古希腊语示例：\r\n  // {\r\n  //   code: 'grc',\r\n  //   name: 'Ancient Greek',\r\n  //   dictionaryFile: 'greek-prosody.json',\r\n  //   poeticForms: [\r\n  //     {\r\n  //       id: 'sapphic_stanza',\r\n  //       name: 'Sapphic Stanza',\r\n  //       description: 'Three sapphic lines + one adonic',\r\n  //       rhymeScheme: [],\r\n  //       meter: SAPPHIC_METER,\r\n  //       lineCount: 4\r\n  //     }\r\n  //   ]\r\n  // }\r\n];\r\n\r\n// 生成 GitHub raw 文件 URL\r\nexport function getRawUrl(repo: typeof GITHUB_CONFIG.devRepo, filePath: string): string {\r\n  return `https://raw.githubusercontent.com/${repo.owner}/${repo.name}/${repo.branch}/${filePath}`;\r\n}\r\n\r\n// 生成词典 URL（根据语言代码）\r\nexport function getDictionaryUrl(languageCode: string): string {\r\n  const language = SUPPORTED_LANGUAGES.find(lang => lang.code === languageCode);\r\n  if (!language) {\r\n    throw new Error(`Unsupported language: ${languageCode}`);\r\n  }\r\n  return getRawUrl(GITHUB_CONFIG.devRepo, `public/data/${language.dictionaryFile}`);\r\n}\r\n\r\n// 数据文件路径（兼容旧代码）\r\nexport const DATA_URLS = {\r\n  cmuDict: getDictionaryUrl('en') // 默认英语\r\n};\r\n","import { DictionaryService } from './dictionary';\r\nimport { SonnetAnalyzer } from './analyzer';\r\nimport type { SonnetAnalysis, LineAnalysis, SonnetForm } from './types';\r\nimport { getDictionaryUrl, SUPPORTED_LANGUAGES } from './config';\r\n\r\n// Initialize services\r\nconst dictionary = new DictionaryService();\r\nconst analyzer = new SonnetAnalyzer(dictionary);\r\n\r\n// Dictionary loading state\r\nlet dictionaryLoaded = false;\r\nlet currentLanguage = 'en'; // 当前使用的语言\r\nlet currentForm: SonnetForm | null = null; // 当前选择的诗歌形式\r\n\r\n// Check if running in Tauri (desktop app)\r\nconst isTauri = '__TAURI__' in window;\r\n\r\n// Load dictionary from remote source (web) or local file (Tauri)\r\nasync function loadDictionary(languageCode: string = 'en') {\r\n  try {\r\n    let dictionaryData;\r\n    dictionaryLoaded = false; // 重置状态\r\n    \r\n    if (isTauri) {\r\n      // Desktop app: load from bundled local file\r\n      console.log(`Loading dictionary from local file (Tauri mode) - Language: ${languageCode}...`);\r\n      const language = SUPPORTED_LANGUAGES.find(lang => lang.code === languageCode);\r\n      if (!language) {\r\n        throw new Error(`Unsupported language: ${languageCode}`);\r\n      }\r\n      const response = await fetch(`/data/${language.dictionaryFile}`);\r\n      if (!response.ok) {\r\n        throw new Error(`Failed to load local dictionary: ${response.statusText}`);\r\n      }\r\n      dictionaryData = await response.json();\r\n      console.log(`Dictionary loaded successfully from local file - ${language.name}`);\r\n    } else {\r\n      // Web app: load from GitHub (saves hosting space)\r\n      console.log(`Loading dictionary from GitHub (web mode) - Language: ${languageCode}...`);\r\n      const dictionaryUrl = getDictionaryUrl(languageCode);\r\n      const response = await fetch(dictionaryUrl);\r\n      if (!response.ok) {\r\n        throw new Error(`Failed to load dictionary: ${response.statusText}`);\r\n      }\r\n      dictionaryData = await response.json();\r\n      console.log('Dictionary loaded successfully from GitHub repository');\r\n    }\r\n    \r\n    await dictionary.loadDictionary(dictionaryData, languageCode);\r\n    currentLanguage = languageCode;\r\n    dictionaryLoaded = true;\r\n  } catch (error) {\r\n    console.error('Error loading dictionary:', error);\r\n    const errorMsg = isTauri \r\n      ? 'Failed to load pronunciation dictionary from local files.'\r\n      : 'Failed to load pronunciation dictionary. Please check your internet connection.';\r\n    alert(errorMsg);\r\n  }\r\n}\r\n\r\n// Load dictionary on startup\r\nloadDictionary();\r\n\r\n// DOM elements\r\nconst languageSelect = document.getElementById('languageSelect') as HTMLSelectElement;\r\nconst poemInput = document.getElementById('poemInput') as HTMLTextAreaElement;\r\nconst sonnetForm = document.getElementById('sonnetForm') as HTMLSelectElement;\r\nconst analyzeBtn = document.getElementById('analyzeBtn') as HTMLButtonElement;\r\nconst clearBtn = document.getElementById('clearBtn') as HTMLButtonElement;\r\nconst output = document.getElementById('output') as HTMLDivElement;\r\n\r\n// Populate language selector\r\nfunction initLanguageSelector() {\r\n  languageSelect.innerHTML = '';\r\n  for (const lang of SUPPORTED_LANGUAGES) {\r\n    const option = document.createElement('option');\r\n    option.value = lang.code;\r\n    option.textContent = lang.name;\r\n    if (lang.code === currentLanguage) {\r\n      option.selected = true;\r\n    }\r\n    languageSelect.appendChild(option);\r\n  }\r\n}\r\n\r\n// Populate poetic form selector based on current language\r\nfunction updateFormSelector() {\r\n  sonnetForm.innerHTML = '';\r\n  const language = SUPPORTED_LANGUAGES.find(lang => lang.code === currentLanguage);\r\n  \r\n  if (!language || language.poeticForms.length === 0) {\r\n    const option = document.createElement('option');\r\n    option.textContent = 'No forms available';\r\n    option.disabled = true;\r\n    sonnetForm.appendChild(option);\r\n    currentForm = null;\r\n    return;\r\n  }\r\n\r\n  for (const form of language.poeticForms) {\r\n    const option = document.createElement('option');\r\n    option.value = form.id;\r\n    option.textContent = form.name;\r\n    option.title = form.description;\r\n    sonnetForm.appendChild(option);\r\n  }\r\n  \r\n  // Set the first form as current\r\n  if (language.poeticForms.length > 0) {\r\n    currentForm = language.poeticForms[0];\r\n  }\r\n}\r\n\r\n// Handle language change\r\nlanguageSelect.addEventListener('change', async () => {\r\n  const newLanguage = languageSelect.value;\r\n  if (newLanguage !== currentLanguage) {\r\n    console.log(`Switching language to: ${newLanguage}`);\r\n    output.innerHTML = '<p style=\"color: #999; font-style: italic;\">Loading dictionary...</p>';\r\n    await loadDictionary(newLanguage);\r\n    if (dictionaryLoaded) {\r\n      updateFormSelector(); // Update available forms\r\n      output.innerHTML = '<p style=\"color: #999; font-style: italic;\">Dictionary loaded. Ready to analyze.</p>';\r\n    }\r\n  }\r\n});\r\n\r\n// Handle form change\r\nsonnetForm.addEventListener('change', () => {\r\n  const formId = sonnetForm.value;\r\n  const language = SUPPORTED_LANGUAGES.find(lang => lang.code === currentLanguage);\r\n  if (language) {\r\n    currentForm = language.poeticForms.find(form => form.id === formId) || null;\r\n  }\r\n});\r\n\r\n// Initialize selectors\r\ninitLanguageSelector();\r\nupdateFormSelector();\r\n\r\n/**\r\n * Get color for rhyme scheme letter\r\n */\r\nfunction getRhymeColor(letter: string): string {\r\n  const colors: { [key: string]: string } = {\r\n    'A': '#8B4513', // Saddle Brown\r\n    'B': '#4682B4', // Steel Blue  \r\n    'C': '#6B8E23', // Olive Drab\r\n    'D': '#B8860B', // Dark Goldenrod\r\n    'E': '#8B008B', // Dark Magenta\r\n    'F': '#CD5C5C', // Indian Red\r\n    'G': '#2F4F4F', // Dark Slate Gray\r\n    'H': '#556B2F', // Dark Olive Green\r\n  };\r\n  return colors[letter] || '#666';\r\n}\r\n\r\n/**\r\n * Find which rhyme group has issues and which lines to highlight\r\n */\r\nfunction getRhymeErrorLines(analysis: SonnetAnalysis): Set<number> {\r\n  const errorLines = new Set<number>();\r\n  \r\n  // Check each rhyme group\r\n  for (const [letter, lineIndices] of Object.entries(analysis.rhymeGroups)) {\r\n    if (lineIndices.length <= 1) continue; // Skip single-line groups\r\n    \r\n    // Get rhyme keys for this group\r\n    const rhymeKeys = lineIndices.map(i => analysis.lines[i].rhymeKey);\r\n    const validRhymes = rhymeKeys.filter(r => r !== '');\r\n    const uniqueRhymes = new Set(validRhymes);\r\n    \r\n    // If there are mismatches, use first line's rhyme as baseline\r\n    if (uniqueRhymes.size > 1) {\r\n      const rhymeCounts = new Map<string, number[]>();\r\n      lineIndices.forEach((lineIdx, i) => {\r\n        const key = rhymeKeys[i];\r\n        if (!rhymeCounts.has(key)) {\r\n          rhymeCounts.set(key, []);\r\n        }\r\n        rhymeCounts.get(key)!.push(lineIdx);\r\n      });\r\n      \r\n      // Determine baseline rhyme: use first line's rhyme, or most common if first is empty\r\n      let baselineRhyme = rhymeKeys[0];\r\n      if (baselineRhyme === '') {\r\n        // First line has no rhyme, find the most common rhyme\r\n        let maxCount = 0;\r\n        for (const [key, lines] of rhymeCounts.entries()) {\r\n          if (key !== '' && lines.length > maxCount) {\r\n            maxCount = lines.length;\r\n            baselineRhyme = key;\r\n          }\r\n        }\r\n      }\r\n      \r\n      // Mark all lines that don't match the baseline as errors\r\n      lineIndices.forEach((lineIdx, i) => {\r\n        if (rhymeKeys[i] !== baselineRhyme) {\r\n          errorLines.add(lineIdx);\r\n        }\r\n      });\r\n    }\r\n  }\r\n  \r\n  return errorLines;\r\n}\r\n\r\n/**\r\n * Render a single line with syllable highlighting\r\n */\r\nfunction renderLine(line: LineAnalysis, rhymeLetter: string, analysis: SonnetAnalysis, rhymeErrorLines: Set<number>): HTMLElement {\r\n  const lineDiv = document.createElement('div');\r\n  lineDiv.className = 'line';\r\n  \r\n  // Check if this line has meter issues (skip lines with too few/many syllables)\r\n  const shouldCheckMeter = line.words.length > 0 && \r\n    Math.abs(line.stressPattern.length - (line.expectedStressPattern?.length || 10)) <= 2;\r\n  \r\n  if (shouldCheckMeter && !line.meterValid) {\r\n    lineDiv.classList.add('meter-invalid');\r\n  }\r\n\r\n  // Line number\r\n  const lineNumber = document.createElement('span');\r\n  lineNumber.className = 'line-number';\r\n  lineNumber.textContent = `${line.lineNumber}.`;\r\n  lineDiv.appendChild(lineNumber);\r\n\r\n  // Render each word with syllables\r\n  for (const word of line.words) {\r\n    const wordSpan = document.createElement('span');\r\n    wordSpan.className = 'word';\r\n\r\n    if (word.found && word.syllables.length > 0) {\r\n      // Get syllable boundaries for the word\r\n      const syllableBoundaries = dictionary.syllabifyWord(word.originalWord, word.syllables);\r\n      const wordText = word.originalWord;\r\n      \r\n      // Calculate global syllable index for meter checking\r\n      let globalSyllableIndex = 0;\r\n      if (shouldCheckMeter && !line.meterValid && line.expectedStressPattern) {\r\n        for (const w of line.words) {\r\n          if (w === word) break;\r\n          globalSyllableIndex += w.syllables.length;\r\n        }\r\n      }\r\n      \r\n      // Render each syllable part separately\r\n      for (let i = 0; i < word.syllables.length; i++) {\r\n        const syllable = word.syllables[i];\r\n        const [start, end] = syllableBoundaries[i] || [0, wordText.length - 1];\r\n        const syllableText = wordText.substring(start, end + 1);\r\n        \r\n        // Determine stress class - only apply color to stressed syllables\r\n        let stressClass = 'stress-0';\r\n        if (syllable.stress === 1) {\r\n          stressClass = 'stress-1';\r\n        } else if (syllable.stress === 2) {\r\n          stressClass = 'stress-2';\r\n        }\r\n        \r\n        const syllableSpan = document.createElement('span');\r\n        syllableSpan.className = `syllable ${stressClass}`;\r\n        syllableSpan.textContent = syllableText;\r\n        \r\n        // Check meter pattern and mark correct/incorrect stresses\r\n        if (line.expectedStressPattern) {\r\n          const expectedIndex = globalSyllableIndex + i;\r\n          if (expectedIndex < line.expectedStressPattern.length) {\r\n            const expected = line.expectedStressPattern[expectedIndex];\r\n            const actual = syllable.stress;\r\n            \r\n            // Check if this stress matches the expected iambic pattern (light-heavy)\r\n            // Expected 1 (heavy position) + actual 1 (primary stress) = correct!\r\n            if (expected === 1 && actual === 1) {\r\n              syllableSpan.classList.add('meter-correct');\r\n            }\r\n            // Expected 1 (heavy position) + actual 2 (secondary stress) = also correct!\r\n            else if (expected === 1 && actual === 2) {\r\n              syllableSpan.classList.add('meter-correct-secondary');\r\n            }\r\n            // Mark as error if expected stress (1) but got unstressed (0)\r\n            else if (shouldCheckMeter && !line.meterValid && expected === 1 && actual === 0) {\r\n              syllableSpan.classList.add('meter-error');\r\n            }\r\n          }\r\n        }\r\n        \r\n        syllableSpan.title = `Syllable ${i + 1}/${word.syllables.length}, Stress: ${syllable.stress}`;\r\n        wordSpan.appendChild(syllableSpan);\r\n      }\r\n      \r\n      // Add overall word tooltip\r\n      wordSpan.title = `Syllables: ${word.syllables.length}, Stress pattern: ${word.syllables.map(s => s.stress).join('')}`;\r\n    } else {\r\n      // Word not found in dictionary - add gray background\r\n      const notFoundSpan = document.createElement('span');\r\n      notFoundSpan.className = 'word-not-found';\r\n      notFoundSpan.textContent = word.originalWord;\r\n      notFoundSpan.title = 'Word not found in dictionary';\r\n      wordSpan.appendChild(notFoundSpan);\r\n    }\r\n\r\n    lineDiv.appendChild(wordSpan);\r\n    lineDiv.appendChild(document.createTextNode(' '));\r\n  }\r\n\r\n  // Add rhyme marker with color and optional error highlight\r\n  const rhymeMarker = document.createElement('span');\r\n  rhymeMarker.className = 'rhyme-marker';\r\n  rhymeMarker.textContent = rhymeLetter;\r\n  rhymeMarker.style.color = getRhymeColor(rhymeLetter);\r\n  \r\n  // Highlight rhyme marker if this line has a rhyme error\r\n  if (rhymeErrorLines.has(line.lineNumber - 1)) {\r\n    rhymeMarker.classList.add('rhyme-error');\r\n  }\r\n  \r\n  lineDiv.appendChild(rhymeMarker);\r\n\r\n  // Add line text as tooltip\r\n  lineDiv.title = line.text;\r\n\r\n  return lineDiv;\r\n}\r\n\r\n/**\r\n * Render the complete analysis\r\n */\r\nfunction renderAnalysis(analysis: SonnetAnalysis): void {\r\n  output.innerHTML = '';\r\n\r\n  // Check for unknown words and show warning\r\n  const unknownWords = new Set<string>();\r\n  for (const line of analysis.lines) {\r\n    for (const word of line.words) {\r\n      if (!word.found) {\r\n        unknownWords.add(word.originalWord);\r\n      }\r\n    }\r\n  }\r\n\r\n  // Show warning if there are unknown words\r\n  if (unknownWords.size > 0) {\r\n    const warning = document.createElement('div');\r\n    warning.className = 'warning-box';\r\n    warning.innerHTML = `\r\n      <strong>⚠️ Words not in dictionary:</strong> \r\n      ${Array.from(unknownWords).join(', ')}\r\n      <br><small>Analysis may be less accurate. Syllable counts and rhymes are estimated.</small>\r\n    `;\r\n    output.appendChild(warning);\r\n  }\r\n\r\n  // Get rhyme error lines\r\n  const rhymeErrorLines = getRhymeErrorLines(analysis);\r\n\r\n  // Render lines\r\n  const linesContainer = document.createElement('div');\r\n  analysis.lines.forEach((line, index) => {\r\n    const rhymeLetter = analysis.form.rhymeScheme[index] || '?';\r\n    const lineElement = renderLine(line, rhymeLetter, analysis, rhymeErrorLines);\r\n    linesContainer.appendChild(lineElement);\r\n  });\r\n  output.appendChild(linesContainer);\r\n\r\n  // Render summary\r\n  const summary = document.createElement('div');\r\n  summary.className = 'summary';\r\n\r\n  const summaryTitle = document.createElement('h3');\r\n  summaryTitle.textContent = 'Analysis Summary';\r\n  summary.appendChild(summaryTitle);\r\n\r\n  // Form info\r\n  const formInfo = document.createElement('div');\r\n  formInfo.className = 'summary-item';\r\n  formInfo.innerHTML = `<strong>Form:</strong> ${analysis.form.name}<br>\r\n                        <strong>Expected Meter:</strong> ${analysis.form.meter.name} (${analysis.form.meter.description})<br>\r\n                        <strong>Expected Rhyme Scheme:</strong> ${analysis.form.rhymeScheme.join('')}`;\r\n  summary.appendChild(formInfo);\r\n\r\n  // Meter validation\r\n  const meterItem = document.createElement('div');\r\n  meterItem.className = `summary-item ${analysis.meterValid ? 'valid' : 'invalid'}`;\r\n  meterItem.innerHTML = `<strong>Meter:</strong> ${analysis.meterValid ? '✓ Valid' : '✗ Issues Found'}`;\r\n  \r\n  if (!analysis.meterValid && analysis.meterIssues.length > 0) {\r\n    analysis.meterIssues.forEach(issue => {\r\n      const issueDiv = document.createElement('div');\r\n      issueDiv.className = 'issue';\r\n      issueDiv.textContent = issue;\r\n      meterItem.appendChild(issueDiv);\r\n    });\r\n  }\r\n  summary.appendChild(meterItem);\r\n\r\n  // Rhyme scheme validation\r\n  const rhymeItem = document.createElement('div');\r\n  rhymeItem.className = `summary-item ${analysis.rhymeSchemeValid ? 'valid' : 'invalid'}`;\r\n  rhymeItem.innerHTML = `<strong>Rhyme Scheme:</strong> ${analysis.rhymeSchemeValid ? '✓ Valid' : '✗ Issues Found'}`;\r\n  \r\n  if (!analysis.rhymeSchemeValid && analysis.rhymeIssues.length > 0) {\r\n    analysis.rhymeIssues.forEach(issue => {\r\n      const issueDiv = document.createElement('div');\r\n      issueDiv.className = 'issue';\r\n      issueDiv.textContent = issue;\r\n      rhymeItem.appendChild(issueDiv);\r\n    });\r\n  }\r\n  summary.appendChild(rhymeItem);\r\n\r\n  output.appendChild(summary);\r\n}\r\n\r\n/**\r\n * Handle analyze button click\r\n */\r\nanalyzeBtn.addEventListener('click', () => {\r\n  const text = poemInput.value.trim();\r\n\r\n  if (!text) {\r\n    alert('Please enter a sonnet to analyze.');\r\n    return;\r\n  }\r\n\r\n  if (!dictionaryLoaded) {\r\n    alert('Dictionary is still loading. Please wait a moment and try again.');\r\n    return;\r\n  }\r\n\r\n  if (!currentForm) {\r\n    alert('Please select a poetic form.');\r\n    return;\r\n  }\r\n\r\n  try {\r\n    const analysis = analyzer.analyzeSonnet(text, currentForm);\r\n    renderAnalysis(analysis);\r\n  } catch (error) {\r\n    console.error('Analysis error:', error);\r\n    output.innerHTML = `<p style=\"color: red;\">Error analyzing sonnet: ${error}</p>`;\r\n  }\r\n});\r\n\r\n// Clear button handler\r\nclearBtn.addEventListener('click', () => {\r\n  poemInput.value = '';\r\n  output.innerHTML = '<p style=\"color: #999; font-style: italic;\">Enter a sonnet and click \"Analyze Sonnet\" to see the results.</p>';\r\n});\r\n\r\n// Load sample sonnet\r\nconst sampleSonnet = `Shall I compare thee to a summer's day\r\nThou art more lovely and more temperate\r\nRough winds do shake the darling buds of May\r\nAnd summer's lease hath all too short a date\r\nSometime too hot the eye of heaven shines\r\nAnd often is his gold complexion dimmed\r\nAnd every fair from fair sometime declines\r\nBy chance or nature's changing course untrimmed\r\nBut thy eternal summer shall not fade\r\nNor lose possession of that fair thou owest\r\nNor shall death brag thou wanderest in his shade\r\nWhen in eternal lines to time thou grow\r\nSo long as men can breathe or eyes can see\r\nSo long lives this and this gives life to thee`;\r\n\r\npoemInput.value = sampleSonnet;\r\n\r\nconsole.log('Sonnet Checker loaded successfully!');\r\n"],"names":["DictionaryService","dictData","languageCode","stored","error","word","phonemes","normalized","pronunciations","syllables","currentSyllable","currentStress","phoneme","stressMatch","lastVowelIndex","i","p","lower","specialCases","count","vowels","previousWasVowel","char","isVowel","beforeEs","before","tripleVowelMatch","match","syllableCount","stressPosition","stress","rhymeKey","result","vowelPositions","avgLength","start","end","vowelPos","prevVowel","consonantCount","half","tokenizeLine","line","removePunctuation","SonnetAnalyzer","dictionary","lineText","lineNumber","words","wordAnalyses","stressPattern","cleaned","analysis","syllable","actual","expected","meterType","lines","expectedScheme","rhymeGroups","rhymeKeys","issues","letter","lineIndices","rhymes","validRhymes","r","uniqueRhymes","text","form","lineAnalyses","index","rhymeValidation","meterIssues","GITHUB_CONFIG","IAMBIC_PENTAMETER","ENGLISH_FORMS","SUPPORTED_LANGUAGES","getRawUrl","repo","filePath","getDictionaryUrl","language","lang","analyzer","dictionaryLoaded","currentLanguage","currentForm","isTauri","loadDictionary","dictionaryData","response","dictionaryUrl","languageSelect","poemInput","sonnetForm","analyzeBtn","clearBtn","output","initLanguageSelector","option","updateFormSelector","newLanguage","formId","getRhymeColor","getRhymeErrorLines","errorLines","rhymeCounts","lineIdx","key","baselineRhyme","maxCount","renderLine","rhymeLetter","rhymeErrorLines","lineDiv","shouldCheckMeter","wordSpan","syllableBoundaries","wordText","globalSyllableIndex","w","syllableText","stressClass","syllableSpan","expectedIndex","s","notFoundSpan","rhymeMarker","renderAnalysis","unknownWords","warning","linesContainer","lineElement","summary","summaryTitle","formInfo","meterItem","issue","issueDiv","rhymeItem","sampleSonnet"],"mappings":"ssBAKO,MAAMA,CAAkB,CAAxB,aAAA,CACL,KAAQ,KAA0B,CAAA,EAClC,KAAQ,gBAA0B,KAClC,KAAQ,WAAgC,CAAA,CAAC,CAKzC,MAAM,eAAeC,EAA6BC,EAAuB,KAAqB,CAC5F,KAAK,KAAOD,EACZ,KAAK,gBAAkBC,EAEvB,KAAK,qBAAA,CACP,CAKQ,sBAA6B,CACnC,GAAI,CACF,MAAMC,EAAS,aAAa,QAAQ,cAAc,KAAK,eAAe,EAAE,EACpEA,IACF,KAAK,WAAa,KAAK,MAAMA,CAAM,EACnC,QAAQ,IAAI,UAAU,OAAO,KAAK,KAAK,UAAU,EAAE,MAAM,eAAe,EAE5E,OAASC,EAAO,CACd,QAAQ,MAAM,oCAAqCA,CAAK,EACxD,KAAK,WAAa,CAAA,CACpB,CACF,CAKQ,sBAA6B,CACnC,GAAI,CACF,aAAa,QACX,cAAc,KAAK,eAAe,GAClC,KAAK,UAAU,KAAK,UAAU,CAAA,CAElC,OAASA,EAAO,CACd,QAAQ,MAAM,oCAAqCA,CAAK,CAC1D,CACF,CAKA,cAAcC,EAAcC,EAA0B,CACpD,MAAMC,EAAaF,EAAK,YAAA,EAAc,QAAQ,WAAY,EAAE,EAC5D,KAAK,WAAWE,CAAU,EAAI,CAACD,CAAQ,EACvC,KAAK,qBAAA,CACP,CAKA,oBAA6B,CAC3B,OAAO,KAAK,eACd,CAOA,OAAOD,EAA+B,CACpC,MAAME,EAAaF,EAAK,YAAA,EAAc,QAAQ,WAAY,EAAE,EAG5D,GAAI,KAAK,WAAWE,CAAU,GAAG,OAAS,EACxC,OAAO,KAAK,WAAWA,CAAU,EAAE,CAAC,EAItC,MAAMC,EAAiB,KAAK,KAAKD,CAAU,EAC3C,MAAI,CAACC,GAAkBA,EAAe,SAAW,EACxC,KAEFA,EAAe,CAAC,CACzB,CAMA,iBAAiBF,EAAgC,CAC/C,MAAMG,EAAwB,CAAA,EAC9B,IAAIC,EAA4B,CAAA,EAC5BC,EAA2B,EAE/B,UAAWC,KAAWN,EAAU,CAC9BI,EAAgB,KAAKE,CAAO,EAG5B,MAAMC,EAAcD,EAAQ,MAAM,QAAQ,EACtCC,IACFF,EAAgB,SAASE,EAAY,CAAC,CAAC,EACvCJ,EAAU,KAAK,CACb,SAAUC,EACV,OAAQC,CAAA,CACT,EACDD,EAAkB,CAAA,EAClBC,EAAgB,EAEpB,CAGA,OAAID,EAAgB,OAAS,GAAKD,EAAU,OAAS,GACnDA,EAAUA,EAAU,OAAS,CAAC,EAAE,SAAS,KAAK,GAAGC,CAAe,EAG3DD,CACT,CAMA,gBAAgBH,EAA4B,CAE1C,IAAIQ,EAAiB,GACrB,QAASC,EAAIT,EAAS,OAAS,EAAGS,GAAK,EAAGA,IACxC,GAAIT,EAASS,CAAC,EAAE,MAAM,QAAQ,EAAG,CAC/BD,EAAiBC,EACjB,KACF,CAGF,OAAID,IAAmB,GAGd,GAIFR,EACJ,MAAMQ,CAAc,EACpB,IAAIE,GAAKA,EAAE,QAAQ,SAAU,EAAE,CAAC,EAChC,KAAK,GAAG,CACb,CAOQ,kBAAkBX,EAAsB,CAC9C,OAAI,KAAK,kBAAoB,KACpB,KAAK,yBAAyBA,CAAI,EAIpC,KAAK,yBAAyBA,CAAI,CAC3C,CAMQ,yBAAyBA,EAAsB,CACrD,MAAMY,EAAQZ,EAAK,YAAA,EAAc,QAAQ,UAAW,EAAE,EACtD,GAAIY,EAAM,SAAW,EAAG,MAAO,GAG/B,MAAMC,EAA0C,CAE9C,IAAO,EAAG,KAAQ,EAAG,MAAS,EAAG,KAAQ,EAAG,MAAS,EACrD,KAAQ,EAAG,KAAQ,EAAG,IAAO,EAAG,KAAQ,EACxC,QAAW,EAAG,OAAU,EAAG,QAAW,EAAG,QAAW,EACpD,KAAQ,EAAG,KAAQ,EAAG,KAAQ,EAG9B,MAAS,EAAG,OAAU,EAAG,OAAU,EAAG,MAAS,EAC/C,MAAS,EAAG,OAAU,EAAG,MAAS,EAAG,MAAS,EAG9C,OAAU,EAAG,QAAW,EAAG,UAAa,EAGxC,KAAQ,EAAG,KAAQ,EAAG,IAAO,EAAG,MAAS,EACzC,KAAQ,EAAG,KAAQ,EAAG,MAAS,EAAG,KAAQ,EAC1C,IAAO,EAAG,IAAO,EAAG,KAAQ,EAC5B,IAAO,EAAG,IAAO,EAAG,KAAQ,EAC5B,IAAO,EAAG,KAAQ,EAAG,MAAS,CAAA,EAGhC,GAAIA,EAAaD,CAAK,EACpB,OAAOC,EAAaD,CAAK,EAG3B,IAAIE,EAAQ,EACZ,MAAMC,EAAS,SACf,IAAIC,EAAmB,GAGvB,QAAS,EAAI,EAAG,EAAIJ,EAAM,OAAQ,IAAK,CACrC,MAAMK,EAAOL,EAAM,CAAC,EACdM,EAAUH,EAAO,SAASE,CAAI,EAEhCC,GAAW,CAACF,GACdF,IAEFE,EAAmBE,CACrB,CA0BA,GArBIN,EAAM,SAAS,GAAG,IAEhBE,EAAQ,GAAK,CAACF,EAAM,MAAM,2CAA2C,GACvEE,IAGEF,EAAM,MAAM,aAAa,GAO3BA,EAAM,SAAS,IAAI,IAEhBA,EAAM,MAAM,SAAS,GACxBE,KAKAF,EAAM,SAAS,IAAI,GAAKA,EAAM,OAAS,EAAG,CAC5C,MAAMO,EAAWP,EAAM,MAAM,GAAI,EAAE,EAE/B,CAAC,MAAM,SAASO,CAAQ,GAAK,CAACP,EAAM,SAAS,MAAM,GAAK,CAACA,EAAM,SAAS,MAAM,GAChFE,GAEJ,CAwBA,GAdIF,EAAM,MAAM,mBAAmB,GAGjCE,IAIEF,EAAM,MAAM,cAAc,GAG5BE,IAIEF,EAAM,MAAM,aAAa,GAAKA,EAAM,OAAS,EAAG,CAElD,MAAMQ,EAASR,EAAMA,EAAM,OAAS,CAAC,EAChCG,EAAO,SAASK,CAAM,GACzBN,GAEJ,CAGA,MAAMO,EAAmBT,EAAM,MAAM,eAAe,EACpD,GAAIS,EACF,UAAWC,KAASD,EAAkB,CASxC,OAAO,KAAK,IAAI,EAAGP,CAAK,CAC1B,CAMQ,uBAAuBd,EAA4B,CACzD,MAAMuB,EAAgB,KAAK,kBAAkBvB,CAAI,EAC3CI,EAAwB,CAAA,EAG9B,IAAIoB,EAAiB,EAErB,GAAID,IAAkB,EACpBC,EAAiB,UACRD,IAAkB,EAAG,CAG9B,MAAMX,EAAQZ,EAAK,YAAA,EACfY,EAAM,MAAM,0BAA0B,GAE/BA,EAAM,MAAM,iBAAiB,EACtCY,EAAiB,CAIrB,SAAWD,GAAiB,EAAG,CAE7B,MAAMX,EAAQZ,EAAK,YAAA,EACfY,EAAM,MAAM,cAAc,GAEnBA,EAAM,MAAM,YAAY,GAExBA,EAAM,MAAM,YAAY,EAHjCY,EAAiB,KAAK,IAAI,EAAGD,EAAgB,CAAC,EAM9CC,EAAiB,KAAK,IAAI,EAAGD,EAAgB,CAAC,CAElD,CAGA,QAASb,EAAI,EAAGA,EAAIa,EAAeb,IAAK,CACtC,MAAMe,EACJf,IAAMc,EAAiB,EACvB,EAEFpB,EAAU,KAAK,CACb,SAAU,CAAA,EACV,OAAAqB,CAAA,CACD,CACH,CAGA,MAAMC,EAAW1B,EAAK,QAAU,EAC9BA,EAAK,MAAM,EAAE,EAAE,cACfA,EAAK,YAAA,EAEP,MAAO,CACL,KAAMA,EAAK,YAAA,EACX,aAAcA,EACd,UAAAI,EACA,SAAAsB,EACA,MAAO,EAAA,CAEX,CAMA,cAAc1B,EAAcI,EAAgD,CAC1E,MAAMQ,EAAQZ,EAAK,YAAA,EACbe,EAAS,SACTY,EAAkC,CAAA,EAGlCC,EAA2B,CAAA,EACjC,QAASlB,EAAI,EAAGA,EAAIE,EAAM,OAAQF,IAC5BK,EAAO,SAASH,EAAMF,CAAC,CAAC,GAC1BkB,EAAe,KAAKlB,CAAC,EAIzB,GAAIkB,EAAe,SAAW,GAAKxB,EAAU,SAAW,EAEtD,MAAO,CAAC,CAAC,EAAGJ,EAAK,OAAS,CAAC,CAAC,EAI9B,GAAII,EAAU,SAAWwB,EAAe,OAAQ,CAE9C,MAAMC,EAAY7B,EAAK,OAASI,EAAU,OAC1C,QAAS,EAAI,EAAG,EAAIA,EAAU,OAAQ,IAAK,CACzC,MAAM0B,EAAQ,KAAK,MAAM,EAAID,CAAS,EAChCE,EAAM,IAAM3B,EAAU,OAAS,EAAIJ,EAAK,OAAS,EAAI,KAAK,OAAO,EAAI,GAAK6B,CAAS,EAAI,EAC7FF,EAAO,KAAK,CAACG,EAAOC,CAAG,CAAC,CAC1B,CACA,OAAOJ,CACT,CAGA,QAASjB,EAAI,EAAGA,EAAIkB,EAAe,OAAQlB,IAAK,CAC9C,MAAMsB,EAAWJ,EAAelB,CAAC,EACjC,IAAIoB,EACAC,EAEJ,GAAIrB,IAAM,EAERoB,EAAQ,MACH,CAEL,MAAMG,EAAYL,EAAelB,EAAI,CAAC,EAChCwB,EAAiBF,EAAWC,EAAY,EAE9C,GAAIC,IAAmB,EAErBJ,EAAQE,UACCE,IAAmB,EAE5BJ,EAAQG,EAAY,UACXC,IAAmB,EAE5BJ,EAAQG,EAAY,UACXC,IAAmB,EAE5BJ,EAAQG,EAAY,MACf,CAEL,MAAME,EAAO,KAAK,MAAMD,EAAiB,CAAC,EAC1CJ,EAAQG,EAAY,EAAIE,CAC1B,CACF,CAEA,GAAIzB,IAAMkB,EAAe,OAAS,EAEhCG,EAAM/B,EAAK,OAAS,MACf,CAGL,MAAMkC,EADYN,EAAelB,EAAI,CAAC,EACHsB,EAAW,EAE9C,GAAIE,IAAmB,EAErBH,EAAMC,UACGE,IAAmB,EAE5BH,EAAMC,UACGE,IAAmB,EAE5BH,EAAMC,EAAW,UACRE,IAAmB,EAE5BH,EAAMC,EAAW,MACZ,CAEL,MAAMG,EAAO,KAAK,MAAMD,EAAiB,CAAC,EAC1CH,EAAMC,EAAWG,CACnB,CACF,CAEAR,EAAO,KAAK,CAACG,EAAOC,CAAG,CAAC,CAC1B,CAEA,OAAOJ,CACT,CAKA,YAAY3B,EAA4B,CACtC,MAAMC,EAAW,KAAK,OAAOD,CAAI,EAEjC,GAAI,CAACC,EAEH,OAAO,KAAK,uBAAuBD,CAAI,EAGzC,MAAMI,EAAY,KAAK,iBAAiBH,CAAQ,EAC1CyB,EAAW,KAAK,gBAAgBzB,CAAQ,EAE9C,MAAO,CACL,KAAMD,EAAK,YAAA,EACX,aAAcA,EACd,UAAAI,EACA,SAAAsB,EACA,MAAO,EAAA,CAEX,CACF,CC3cO,SAASU,EAAaC,EAAwB,CAEnD,OAAOA,EAAK,OAAO,MAAM,KAAK,EAAE,OAAOrC,GAAQA,EAAK,OAAS,CAAC,CAChE,CAMO,SAASsC,EAAkBtC,EAAsB,CAItD,OAFmBA,EAAK,QAAQ,QAAS,GAAG,EAE1B,QAAQ,cAAe,EAAE,CAC7C,CChBO,MAAMuC,CAAe,CAC1B,YAAoBC,EAA+B,CAA/B,KAAA,WAAAA,CAAgC,CAKpD,YAAYC,EAAkBC,EAAkC,CAC9D,MAAMC,EAAQP,EAAaK,CAAQ,EAC7BG,EAA+B,CAAA,EAC/BC,EAA+B,CAAA,EAErC,UAAW7C,KAAQ2C,EAAO,CACxB,MAAMG,EAAUR,EAAkBtC,CAAI,EACtC,GAAI,CAAC8C,EAAS,SAEd,MAAMC,EAAW,KAAK,WAAW,YAAYD,CAAO,EACpDF,EAAa,KAAKG,CAAQ,EAG1B,UAAWC,KAAYD,EAAS,UAC9BF,EAAc,KAAKG,EAAS,MAAM,CAEtC,CAIA,IAAItB,GADakB,EAAa,OAAS,EAAIA,EAAaA,EAAa,OAAS,CAAC,EAAI,OAC1D,UAAY,GAGrC,GAAIlB,IAAa,IAAMkB,EAAa,OAAS,GAC3C,QAAS,EAAIA,EAAa,OAAS,EAAG,GAAK,EAAG,IAC5C,GAAIA,EAAa,CAAC,EAAE,SAAU,CAC5BlB,EAAWkB,EAAa,CAAC,EAAE,SAC3B,KACF,EAIJ,MAAO,CACL,WAAAF,EACA,KAAMD,EACN,MAAOG,EACP,cAAAC,EACA,SAAAnB,CAAA,CAEJ,CAOA,WAAWuB,EAAuBC,EAAyBC,EAAoB,SAAmB,CAOhG,OALI,KAAK,IAAIF,EAAO,OAASC,EAAS,MAAM,EAAI,GAK5CD,EAAO,SAAWC,EAAS,OACtB,GAILC,IAAc,SACT,KAAK,iBAAiBF,EAAQC,CAAQ,EAGtC,KAAK,iBAAiBD,EAAQC,CAAQ,CAEjD,CAQQ,iBAAiBD,EAAuBC,EAAkC,CAChF,QAASxC,EAAI,EAAGA,EAAIwC,EAAS,OAAQxC,IACnC,GAAIwC,EAASxC,CAAC,IAAM,GAElB,GAAIuC,EAAOvC,CAAC,IAAM,EAEhB,MAAO,WAKLuC,EAAOvC,CAAC,IAAM,EAGhB,SAKN,MAAO,EACT,CAMQ,iBAAiBuC,EAAuBC,EAAkC,CAChF,QAASxC,EAAI,EAAGA,EAAIwC,EAAS,OAAQxC,IAInC,GAHIwC,EAASxC,CAAC,IAAM,GAAKuC,EAAOvC,CAAC,IAAM,GAGnCwC,EAASxC,CAAC,IAAM,GAAKuC,EAAOvC,CAAC,IAAM,EACrC,MAAO,GAGX,MAAO,EACT,CAKA,oBAAoB0C,EAAuBC,EAIzC,CACA,MAAMC,EAA8C,CAAA,EAC9CC,EAA4C,CAAA,EAC5CC,EAAmB,CAAA,EAGzB,QAAS9C,EAAI,EAAGA,EAAI,KAAK,IAAI0C,EAAM,OAAQC,EAAe,MAAM,EAAG3C,IAAK,CACtE,MAAM+C,EAASJ,EAAe3C,CAAC,EACzBgB,EAAW0B,EAAM1C,CAAC,EAAE,SAErB4C,EAAYG,CAAM,IACrBH,EAAYG,CAAM,EAAI,CAAA,EACtBF,EAAUE,CAAM,EAAI,CAAA,GAEtBH,EAAYG,CAAM,EAAE,KAAK/C,CAAC,EAC1B6C,EAAUE,CAAM,EAAE,KAAK/B,CAAQ,CACjC,CAGA,SAAW,CAAC+B,EAAQC,CAAW,IAAK,OAAO,QAAQJ,CAAW,EAAG,CAE/D,GAAII,EAAY,QAAU,EACxB,SAGF,MAAMC,EAASJ,EAAUE,CAAM,EACzBG,EAAcD,EAAO,OAAOE,GAAKA,IAAM,EAAE,EACzCC,EAAe,IAAI,IAAIF,CAAW,EAGpCE,EAAa,KAAO,GACtBN,EAAO,KAAK,eAAeC,CAAM,6BAA6B,MAAM,KAAKK,CAAY,EAAE,KAAK,IAAI,CAAC,EAAE,EAIjGF,EAAY,OAASD,EAAO,QAC9BH,EAAO,KAAK,eAAeC,CAAM,yCAAyC,CAE9E,CAEA,MAAO,CACL,MAAOD,EAAO,SAAW,EACzB,OAAAA,EACA,YAAAF,CAAA,CAEJ,CAKA,cAAcS,EAAcC,EAAkC,CAG5D,MAAMC,EAFQF,EAAK,MAAM;AAAA,CAAI,EAAE,OAAO1B,GAAQA,EAAK,OAAO,OAAS,CAAC,EAEzB,IAAI,CAACA,EAAM6B,IAAU,CAC9D,MAAMnB,EAAW,KAAK,YAAYV,EAAM6B,EAAQ,CAAC,EAGjD,OAAAnB,EAAS,sBAAwBiB,EAAK,MAAM,cAC5CjB,EAAS,WAAa,KAAK,WACzBA,EAAS,cACTiB,EAAK,MAAM,cACXA,EAAK,MAAM,MAAQ,QAAA,EAGdjB,CACT,CAAC,EAGKoB,EAAkB,KAAK,oBAAoBF,EAAcD,EAAK,WAAW,EAGzEI,EAAwB,CAAA,EAC9B,UAAW/B,KAAQ4B,EAEb5B,EAAK,MAAM,SAAW,GAAK,KAAK,IAAIA,EAAK,cAAc,OAAS2B,EAAK,MAAM,cAAc,MAAM,EAAI,GAIlG3B,EAAK,YACR+B,EAAY,KACV,QAAQ/B,EAAK,UAAU,cAAc2B,EAAK,MAAM,cAAc,MAAM,2BACpDA,EAAK,MAAM,cAAc,KAAK,EAAE,CAAC,SAC1C3B,EAAK,cAAc,MAAM,2BAA2BA,EAAK,cAAc,KAAK,EAAE,CAAC,EAAA,EAK5F,MAAO,CACL,MAAO4B,EACP,KAAAD,EACA,iBAAkBG,EAAgB,MAClC,WAAYC,EAAY,SAAW,EACnC,YAAaD,EAAgB,OAC7B,YAAAC,EACA,YAAaD,EAAgB,WAAA,CAEjC,CACF,CClOO,MAAME,EAAgB,CAE3B,QAAS,CACP,MAAO,YACP,KAAM,WACN,OAAQ,MAAA,CASZ,EAGMC,EAAkC,CACtC,KAAM,oBACN,YAAa,qDACb,cAAe,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,CAAC,EAC5C,cAAe,GACf,KAAM,QACR,EAWMC,EAA8B,CAClC,CACE,GAAI,gBACJ,KAAM,uBACN,YAAa,oBACb,YAAa,CAAC,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,GAAG,EAClF,MAAOD,EACP,UAAW,EAAA,EAEb,CACE,GAAI,cACJ,KAAM,6BACN,YAAa,kBACb,YAAa,CAAC,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,GAAG,EAClF,MAAOA,EACP,UAAW,EAAA,EAEb,CACE,GAAI,cACJ,KAAM,6BACN,YAAa,kBACb,YAAa,CAAC,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,GAAG,EAClF,MAAOA,EACP,UAAW,EAAA,CAEf,EAGaE,EAAwC,CACnD,CACE,KAAM,KACN,KAAM,UACN,eAAgB,eAChB,YAAaD,CAAA,CA0CjB,EAGO,SAASE,EAAUC,EAAoCC,EAA0B,CACtF,MAAO,qCAAqCD,EAAK,KAAK,IAAIA,EAAK,IAAI,IAAIA,EAAK,MAAM,IAAIC,CAAQ,EAChG,CAGO,SAASC,EAAiB/E,EAA8B,CAC7D,MAAMgF,EAAWL,EAAoB,KAAKM,GAAQA,EAAK,OAASjF,CAAY,EAC5E,GAAI,CAACgF,EACH,MAAM,IAAI,MAAM,yBAAyBhF,CAAY,EAAE,EAEzD,OAAO4E,EAAUJ,EAAc,QAAS,eAAeQ,EAAS,cAAc,EAAE,CAClF,CAIWD,EAAiB,IAAI,EChIhC,MAAMpC,EAAa,IAAI7C,EACjBoF,EAAW,IAAIxC,EAAeC,CAAU,EAG9C,IAAIwC,EAAmB,GACnBC,EAAkB,KAClBC,EAAiC,KAGrC,MAAMC,EAAU,cAAe,OAG/B,eAAeC,EAAevF,EAAuB,KAAM,CACzD,GAAI,CACF,IAAIwF,EAGJ,GAFAL,EAAmB,GAEfG,EAAS,CAEX,QAAQ,IAAI,+DAA+DtF,CAAY,KAAK,EAC5F,MAAMgF,EAAWL,EAAoB,KAAKM,GAAQA,EAAK,OAASjF,CAAY,EAC5E,GAAI,CAACgF,EACH,MAAM,IAAI,MAAM,yBAAyBhF,CAAY,EAAE,EAEzD,MAAMyF,EAAW,MAAM,MAAM,SAAST,EAAS,cAAc,EAAE,EAC/D,GAAI,CAACS,EAAS,GACZ,MAAM,IAAI,MAAM,oCAAoCA,EAAS,UAAU,EAAE,EAE3ED,EAAiB,MAAMC,EAAS,KAAA,EAChC,QAAQ,IAAI,oDAAoDT,EAAS,IAAI,EAAE,CACjF,KAAO,CAEL,QAAQ,IAAI,yDAAyDhF,CAAY,KAAK,EACtF,MAAM0F,EAAgBX,EAAiB/E,CAAY,EAC7CyF,EAAW,MAAM,MAAMC,CAAa,EAC1C,GAAI,CAACD,EAAS,GACZ,MAAM,IAAI,MAAM,8BAA8BA,EAAS,UAAU,EAAE,EAErED,EAAiB,MAAMC,EAAS,KAAA,EAChC,QAAQ,IAAI,uDAAuD,CACrE,CAEA,MAAM9C,EAAW,eAAe6C,EAAgBxF,CAAY,EAC5DoF,EAAkBpF,EAClBmF,EAAmB,EACrB,OAASjF,EAAO,CACd,QAAQ,MAAM,4BAA6BA,CAAK,EAIhD,MAHiBoF,EACb,4DACA,iFACU,CAChB,CACF,CAGAC,EAAA,EAGA,MAAMI,EAAiB,SAAS,eAAe,gBAAgB,EACzDC,EAAY,SAAS,eAAe,WAAW,EAC/CC,EAAa,SAAS,eAAe,YAAY,EACjDC,EAAa,SAAS,eAAe,YAAY,EACjDC,EAAW,SAAS,eAAe,UAAU,EAC7CC,EAAS,SAAS,eAAe,QAAQ,EAG/C,SAASC,GAAuB,CAC9BN,EAAe,UAAY,GAC3B,UAAWV,KAAQN,EAAqB,CACtC,MAAMuB,EAAS,SAAS,cAAc,QAAQ,EAC9CA,EAAO,MAAQjB,EAAK,KACpBiB,EAAO,YAAcjB,EAAK,KACtBA,EAAK,OAASG,IAChBc,EAAO,SAAW,IAEpBP,EAAe,YAAYO,CAAM,CACnC,CACF,CAGA,SAASC,GAAqB,CAC5BN,EAAW,UAAY,GACvB,MAAMb,EAAWL,EAAoB,KAAKM,GAAQA,EAAK,OAASG,CAAe,EAE/E,GAAI,CAACJ,GAAYA,EAAS,YAAY,SAAW,EAAG,CAClD,MAAMkB,EAAS,SAAS,cAAc,QAAQ,EAC9CA,EAAO,YAAc,qBACrBA,EAAO,SAAW,GAClBL,EAAW,YAAYK,CAAM,EAC7Bb,EAAc,KACd,MACF,CAEA,UAAWlB,KAAQa,EAAS,YAAa,CACvC,MAAMkB,EAAS,SAAS,cAAc,QAAQ,EAC9CA,EAAO,MAAQ/B,EAAK,GACpB+B,EAAO,YAAc/B,EAAK,KAC1B+B,EAAO,MAAQ/B,EAAK,YACpB0B,EAAW,YAAYK,CAAM,CAC/B,CAGIlB,EAAS,YAAY,OAAS,IAChCK,EAAcL,EAAS,YAAY,CAAC,EAExC,CAGAW,EAAe,iBAAiB,SAAU,SAAY,CACpD,MAAMS,EAAcT,EAAe,MAC/BS,IAAgBhB,IAClB,QAAQ,IAAI,0BAA0BgB,CAAW,EAAE,EACnDJ,EAAO,UAAY,wEACnB,MAAMT,EAAea,CAAW,EAC5BjB,IACFgB,EAAA,EACAH,EAAO,UAAY,wFAGzB,CAAC,EAGDH,EAAW,iBAAiB,SAAU,IAAM,CAC1C,MAAMQ,EAASR,EAAW,MACpBb,EAAWL,EAAoB,KAAKM,GAAQA,EAAK,OAASG,CAAe,EAC3EJ,IACFK,EAAcL,EAAS,YAAY,QAAab,EAAK,KAAOkC,CAAM,GAAK,KAE3E,CAAC,EAGDJ,EAAA,EACAE,EAAA,EAKA,SAASG,EAAc1C,EAAwB,CAW7C,MAV0C,CACxC,EAAK,UACL,EAAK,UACL,EAAK,UACL,EAAK,UACL,EAAK,UACL,EAAK,UACL,EAAK,UACL,EAAK,SAAA,EAEOA,CAAM,GAAK,MAC3B,CAKA,SAAS2C,EAAmBrD,EAAuC,CACjE,MAAMsD,MAAiB,IAGvB,SAAW,CAAC5C,EAAQC,CAAW,IAAK,OAAO,QAAQX,EAAS,WAAW,EAAG,CACxE,GAAIW,EAAY,QAAU,EAAG,SAG7B,MAAMH,EAAYG,EAAY,IAAIhD,GAAKqC,EAAS,MAAMrC,CAAC,EAAE,QAAQ,EAC3DkD,EAAcL,EAAU,OAAO,GAAK,IAAM,EAAE,EAIlD,GAHqB,IAAI,IAAIK,CAAW,EAGvB,KAAO,EAAG,CACzB,MAAM0C,MAAkB,IACxB5C,EAAY,QAAQ,CAAC6C,EAAS7F,IAAM,CAClC,MAAM8F,EAAMjD,EAAU7C,CAAC,EAClB4F,EAAY,IAAIE,CAAG,GACtBF,EAAY,IAAIE,EAAK,EAAE,EAEzBF,EAAY,IAAIE,CAAG,EAAG,KAAKD,CAAO,CACpC,CAAC,EAGD,IAAIE,EAAgBlD,EAAU,CAAC,EAC/B,GAAIkD,IAAkB,GAAI,CAExB,IAAIC,EAAW,EACf,SAAW,CAACF,EAAKpD,CAAK,IAAKkD,EAAY,UACjCE,IAAQ,IAAMpD,EAAM,OAASsD,IAC/BA,EAAWtD,EAAM,OACjBqD,EAAgBD,EAGtB,CAGA9C,EAAY,QAAQ,CAAC6C,EAAS7F,IAAM,CAC9B6C,EAAU7C,CAAC,IAAM+F,GACnBJ,EAAW,IAAIE,CAAO,CAE1B,CAAC,CACH,CACF,CAEA,OAAOF,CACT,CAKA,SAASM,EAAWtE,EAAoBuE,EAAqB7D,EAA0B8D,EAA2C,CAChI,MAAMC,EAAU,SAAS,cAAc,KAAK,EAC5CA,EAAQ,UAAY,OAGpB,MAAMC,EAAmB1E,EAAK,MAAM,OAAS,GAC3C,KAAK,IAAIA,EAAK,cAAc,QAAUA,EAAK,uBAAuB,QAAU,GAAG,GAAK,EAElF0E,GAAoB,CAAC1E,EAAK,YAC5ByE,EAAQ,UAAU,IAAI,eAAe,EAIvC,MAAMpE,EAAa,SAAS,cAAc,MAAM,EAChDA,EAAW,UAAY,cACvBA,EAAW,YAAc,GAAGL,EAAK,UAAU,IAC3CyE,EAAQ,YAAYpE,CAAU,EAG9B,UAAW1C,KAAQqC,EAAK,MAAO,CAC7B,MAAM2E,EAAW,SAAS,cAAc,MAAM,EAG9C,GAFAA,EAAS,UAAY,OAEjBhH,EAAK,OAASA,EAAK,UAAU,OAAS,EAAG,CAE3C,MAAMiH,EAAqBzE,EAAW,cAAcxC,EAAK,aAAcA,EAAK,SAAS,EAC/EkH,EAAWlH,EAAK,aAGtB,IAAImH,EAAsB,EAC1B,GAAIJ,GAAoB,CAAC1E,EAAK,YAAcA,EAAK,sBAC/C,UAAW+E,KAAK/E,EAAK,MAAO,CAC1B,GAAI+E,IAAMpH,EAAM,MAChBmH,GAAuBC,EAAE,UAAU,MACrC,CAIF,QAAS1G,EAAI,EAAGA,EAAIV,EAAK,UAAU,OAAQU,IAAK,CAC9C,MAAMsC,EAAWhD,EAAK,UAAUU,CAAC,EAC3B,CAACoB,EAAOC,CAAG,EAAIkF,EAAmBvG,CAAC,GAAK,CAAC,EAAGwG,EAAS,OAAS,CAAC,EAC/DG,EAAeH,EAAS,UAAUpF,EAAOC,EAAM,CAAC,EAGtD,IAAIuF,EAAc,WACdtE,EAAS,SAAW,EACtBsE,EAAc,WACLtE,EAAS,SAAW,IAC7BsE,EAAc,YAGhB,MAAMC,EAAe,SAAS,cAAc,MAAM,EAKlD,GAJAA,EAAa,UAAY,YAAYD,CAAW,GAChDC,EAAa,YAAcF,EAGvBhF,EAAK,sBAAuB,CAC9B,MAAMmF,EAAgBL,EAAsBzG,EAC5C,GAAI8G,EAAgBnF,EAAK,sBAAsB,OAAQ,CACrD,MAAMa,EAAWb,EAAK,sBAAsBmF,CAAa,EACnDvE,EAASD,EAAS,OAIpBE,IAAa,GAAKD,IAAW,EAC/BsE,EAAa,UAAU,IAAI,eAAe,EAGnCrE,IAAa,GAAKD,IAAW,EACpCsE,EAAa,UAAU,IAAI,yBAAyB,EAG7CR,GAAoB,CAAC1E,EAAK,YAAca,IAAa,GAAKD,IAAW,GAC5EsE,EAAa,UAAU,IAAI,aAAa,CAE5C,CACF,CAEAA,EAAa,MAAQ,YAAY7G,EAAI,CAAC,IAAIV,EAAK,UAAU,MAAM,aAAagD,EAAS,MAAM,GAC3FgE,EAAS,YAAYO,CAAY,CACnC,CAGAP,EAAS,MAAQ,cAAchH,EAAK,UAAU,MAAM,qBAAqBA,EAAK,UAAU,OAASyH,EAAE,MAAM,EAAE,KAAK,EAAE,CAAC,EACrH,KAAO,CAEL,MAAMC,EAAe,SAAS,cAAc,MAAM,EAClDA,EAAa,UAAY,iBACzBA,EAAa,YAAc1H,EAAK,aAChC0H,EAAa,MAAQ,+BACrBV,EAAS,YAAYU,CAAY,CACnC,CAEAZ,EAAQ,YAAYE,CAAQ,EAC5BF,EAAQ,YAAY,SAAS,eAAe,GAAG,CAAC,CAClD,CAGA,MAAMa,EAAc,SAAS,cAAc,MAAM,EACjD,OAAAA,EAAY,UAAY,eACxBA,EAAY,YAAcf,EAC1Be,EAAY,MAAM,MAAQxB,EAAcS,CAAW,EAG/CC,EAAgB,IAAIxE,EAAK,WAAa,CAAC,GACzCsF,EAAY,UAAU,IAAI,aAAa,EAGzCb,EAAQ,YAAYa,CAAW,EAG/Bb,EAAQ,MAAQzE,EAAK,KAEdyE,CACT,CAKA,SAASc,EAAe7E,EAAgC,CACtD8C,EAAO,UAAY,GAGnB,MAAMgC,MAAmB,IACzB,UAAWxF,KAAQU,EAAS,MAC1B,UAAW/C,KAAQqC,EAAK,MACjBrC,EAAK,OACR6H,EAAa,IAAI7H,EAAK,YAAY,EAMxC,GAAI6H,EAAa,KAAO,EAAG,CACzB,MAAMC,EAAU,SAAS,cAAc,KAAK,EAC5CA,EAAQ,UAAY,cACpBA,EAAQ,UAAY;AAAA;AAAA,QAEhB,MAAM,KAAKD,CAAY,EAAE,KAAK,IAAI,CAAC;AAAA;AAAA,MAGvChC,EAAO,YAAYiC,CAAO,CAC5B,CAGA,MAAMjB,EAAkBT,EAAmBrD,CAAQ,EAG7CgF,EAAiB,SAAS,cAAc,KAAK,EACnDhF,EAAS,MAAM,QAAQ,CAACV,EAAM6B,IAAU,CACtC,MAAM0C,EAAc7D,EAAS,KAAK,YAAYmB,CAAK,GAAK,IAClD8D,EAAcrB,EAAWtE,EAAMuE,EAAa7D,EAAU8D,CAAe,EAC3EkB,EAAe,YAAYC,CAAW,CACxC,CAAC,EACDnC,EAAO,YAAYkC,CAAc,EAGjC,MAAME,EAAU,SAAS,cAAc,KAAK,EAC5CA,EAAQ,UAAY,UAEpB,MAAMC,EAAe,SAAS,cAAc,IAAI,EAChDA,EAAa,YAAc,mBAC3BD,EAAQ,YAAYC,CAAY,EAGhC,MAAMC,EAAW,SAAS,cAAc,KAAK,EAC7CA,EAAS,UAAY,eACrBA,EAAS,UAAY,0BAA0BpF,EAAS,KAAK,IAAI;AAAA,2DACRA,EAAS,KAAK,MAAM,IAAI,KAAKA,EAAS,KAAK,MAAM,WAAW;AAAA,kEACrDA,EAAS,KAAK,YAAY,KAAK,EAAE,CAAC,GAClGkF,EAAQ,YAAYE,CAAQ,EAG5B,MAAMC,EAAY,SAAS,cAAc,KAAK,EAC9CA,EAAU,UAAY,gBAAgBrF,EAAS,WAAa,QAAU,SAAS,GAC/EqF,EAAU,UAAY,2BAA2BrF,EAAS,WAAa,UAAY,gBAAgB,GAE/F,CAACA,EAAS,YAAcA,EAAS,YAAY,OAAS,GACxDA,EAAS,YAAY,QAAQsF,GAAS,CACpC,MAAMC,EAAW,SAAS,cAAc,KAAK,EAC7CA,EAAS,UAAY,QACrBA,EAAS,YAAcD,EACvBD,EAAU,YAAYE,CAAQ,CAChC,CAAC,EAEHL,EAAQ,YAAYG,CAAS,EAG7B,MAAMG,EAAY,SAAS,cAAc,KAAK,EAC9CA,EAAU,UAAY,gBAAgBxF,EAAS,iBAAmB,QAAU,SAAS,GACrFwF,EAAU,UAAY,kCAAkCxF,EAAS,iBAAmB,UAAY,gBAAgB,GAE5G,CAACA,EAAS,kBAAoBA,EAAS,YAAY,OAAS,GAC9DA,EAAS,YAAY,QAAQsF,GAAS,CACpC,MAAMC,EAAW,SAAS,cAAc,KAAK,EAC7CA,EAAS,UAAY,QACrBA,EAAS,YAAcD,EACvBE,EAAU,YAAYD,CAAQ,CAChC,CAAC,EAEHL,EAAQ,YAAYM,CAAS,EAE7B1C,EAAO,YAAYoC,CAAO,CAC5B,CAKAtC,EAAW,iBAAiB,QAAS,IAAM,CACzC,MAAM5B,EAAO0B,EAAU,MAAM,KAAA,EAE7B,GAAI,CAAC1B,EAAM,CACT,MAAM,mCAAmC,EACzC,MACF,CAEA,GAAI,CAACiB,EAAkB,CACrB,MAAM,kEAAkE,EACxE,MACF,CAEA,GAAI,CAACE,EAAa,CAChB,MAAM,8BAA8B,EACpC,MACF,CAEA,GAAI,CACF,MAAMnC,EAAWgC,EAAS,cAAchB,EAAMmB,CAAW,EACzD0C,EAAe7E,CAAQ,CACzB,OAAShD,EAAO,CACd,QAAQ,MAAM,kBAAmBA,CAAK,EACtC8F,EAAO,UAAY,kDAAkD9F,CAAK,MAC5E,CACF,CAAC,EAGD6F,EAAS,iBAAiB,QAAS,IAAM,CACvCH,EAAU,MAAQ,GAClBI,EAAO,UAAY,+GACrB,CAAC,EAGD,MAAM2C,EAAe;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,gDAerB/C,EAAU,MAAQ+C,EAElB,QAAQ,IAAI,qCAAqC"}